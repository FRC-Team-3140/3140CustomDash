import { U as M, M as v, H as b, O as w } from "./property-C4BPH-wS-7fb0a59c.js";
import { n as x } from "./state-Cn3aen3G-6b8e5a08.js";
import { h as z } from "./query-BrpQj_Qi-db00b239.js";
import { E as S } from "./transform-DR-Bw75L-3629b551.js";
var T = Object.defineProperty, s = (d, o, l, p) => {
  for (var t = void 0, h = d.length - 1, a; h >= 0; h--)
    (a = d[h]) && (t = a(o, l, t) || t);
  return t && T(o, l, t), t;
};
const f = class extends b {
  constructor() {
    super(...arguments), this.vertical = !1, this.ticks = 5, this.min = -1, this.max = 1, this.unit = "", this.prevSize = 0, this.prevTicks = 0, this.prevMin = null, this.prevMax = null;
  }
  setAxis(o) {
    var l;
    const p = this.vertical ? this.clientHeight : this.clientWidth, t = p / Math.max(1, this.ticks - 1), h = 30, { min: a, max: c } = this;
    let y = -1 / 0, m = -1 / 0;
    if (this.prevSize === p && this.prevTicks === this.ticks && this.prevMin === a && this.prevMax === c && !o.has("unit") && !o.has("vertical"))
      return;
    this.prevSize = p, this.prevTicks = this.ticks, this.prevMin = a, this.prevMax = c, this.svg.innerHTML = "";
    const n = S(this.svg).attr("width", this.vertical ? h : p).attr("height", this.vertical ? p : h);
    for (let i = 0; i < this.ticks; i += 1) {
      if (this.vertical ? n.append("line").attr("x1", 0).attr("y1", i * t).attr("x2", 8).attr("y2", i * t) : n.append("line").attr("x1", i * t).attr("y1", 0).attr("x2", i * t).attr("y2", 8), this.vertical) {
        const r = a + i * (c - a) / Math.max(this.ticks - 1, 1);
        n.append("text").attr("x", -3).attr("y", i * t + 4).attr("text-anchor", "end").text(r.toFixed(2) + (this.unit ? ` ${this.unit}` : ""));
      } else {
        const r = (i - y) * t, u = y * t + r * 0.4;
        if (m < 0 || u > m) {
          const g = a + i * (c - a) / Math.max(this.ticks - 1, 1), k = n.append("text").attr("x", i * t).attr("y", 25).attr("text-anchor", "middle").text(g.toFixed(2) + (this.unit ? ` ${this.unit}` : ""));
          m = i * t + (((l = k.node()) == null ? void 0 : l.getBBox().width) ?? 0) / 2, y = i;
        }
      }
      if (i < this.ticks - 1)
        for (let r = 1; r < 4; r += 1)
          this.vertical ? n.append("line").attr("x1", 4).attr("y1", i * t + r * t / 4).attr("x2", 8).attr("y2", i * t + r * t / 4) : n.append("line").attr("x1", i * t + r * t / 4).attr("y1", 0).attr("x2", i * t + r * t / 4).attr("y2", 4);
    }
  }
  firstUpdated() {
    new ResizeObserver(() => {
      this.requestUpdate();
    }).observe(this);
  }
  updated(o) {
    this.setAxis(o);
  }
  render() {
    return w` <svg id="svg"></svg> `;
  }
};
f.styles = M`
    :host {
      display: inline-block;
      position: relative;
    }

    :host([vertical]) {
      height: 100%;
    }

    :host(:not([vertical])) {
      width: 100%;
    }

    svg {
      overflow: visible;
      position: absolute;
      top: 0;
      left: 0;
    }

    line {
      stroke: rgb(150, 150, 150);
      stroke-width: 2;
    }

    text {
      font-weight: normal;
      font-size: 13px;
      fill: var(--frc-axis-text-color, #000);
    }
  `;
let e = f;
s([
  v({ type: Boolean })
], e.prototype, "vertical");
s([
  v({ type: Number })
], e.prototype, "ticks");
s([
  v({ type: Number })
], e.prototype, "min");
s([
  v({ type: Number })
], e.prototype, "max");
s([
  v({ type: String })
], e.prototype, "unit");
s([
  x()
], e.prototype, "prevSize");
s([
  x()
], e.prototype, "prevTicks");
s([
  x()
], e.prototype, "prevMin");
s([
  x()
], e.prototype, "prevMax");
s([
  z("#svg")
], e.prototype, "svg");
customElements.get("frc-axis") || customElements.define("frc-axis", e);
export {
  e as i
};
