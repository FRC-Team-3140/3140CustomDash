import { jsx as K } from "react/jsx-runtime";
import { createContext as Q, useState as X, useContext as Z } from "react";
import { FrcDashboard as ee, dashboardElementConfigs as te } from "@frc-web-components/fwc";
var q = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
}, b = (r, e, t) => (q(r, e, "read from private field"), t ? t.call(r) : e.get(r)), y = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
}, $ = (r, e, t, i) => (q(r, e, "write to private field"), e.set(r, t), t), v = (r, e, t) => (q(r, e, "access private method"), t), ie = typeof global == "object" && global && global.Object === Object && global, ne = typeof self == "object" && self && self.Object === Object && self, se = ie || ne || Function("return this")(), V = se.Symbol, B = V ? V.prototype : void 0;
B && B.toString;
const Y = () => {
};
var A, m, _, U, I, x, C, E, k, M, D, R;
class re {
  constructor(e = {}, t = 0) {
    y(this, C), y(this, k), y(this, D), y(this, A, void 0), y(this, m, {}), y(this, _, void 0), y(this, U, /* @__PURE__ */ new Map()), y(this, I, /* @__PURE__ */ new Map()), y(this, x, /* @__PURE__ */ new Map()), t && $(this, A, setInterval(v(this, C, E).bind(this), t)), Object.entries(e).forEach(([i, c]) => {
      this.updateSource(i, c);
    });
  }
  /**
   * Updates the value of a source in the store. If the source doesn't
   * exist then it is added. Should only be called internally by the
   * source provider.
   *
   * @protected
   * @param {string} key - The source's key. This is a string separated
   * by '/'.
   * @param {*} value - The new value.
   */
  updateSource(e, t) {
    clearTimeout(b(this, _)), b(this, m)[e] === void 0 ? b(this, m)[e] = {
      first: {
        type: "change",
        value: t
      }
    } : b(this, m)[e].last = {
      type: "change",
      value: t
    }, b(this, A) || v(this, C, E).call(this);
  }
  /**
   * Removes an existing source from the store. If the source
   * doesn't exist this does nothing. Should only be called
   * internally by the source provider.
   *
   * @protected
   * @param {string} key - The source's key. This is a string separated
   * by '/'.
   */
  removeSource(e) {
    b(this, m)[e] === void 0 ? b(this, m)[e] = {
      first: {
        type: "removal"
      }
    } : b(this, m)[e].last = {
      type: "removal"
    }, b(this, A) || v(this, C, E).call(this);
  }
  /**
   * Removes all sources in the store for this provider. Should only be
   * called internally by the source provider.
   *
   * @protected
   * @param {function} callback - An optional callback. Called when sources
   * have been cleared.
   */
  clearSources(e = Y) {
    v(this, C, E).call(this, () => {
      b(this, U).forEach((t) => t()), e();
    });
  }
  /**
   * Removes all sources in the store for this provider after a period of time.
   * If a source is set or this function is called before that period of time
   * ends, sources will not be cleared. This is useful for preventing sources
   * from being cleared on an unreliable network. Should only be called internally
   * by the source provider.
   *
   * @protected
   * @param {number} timeout - The period of time before clearing the sources
   * in milliseconds.
   * @param {function} callback - An optional callback. Called when sources
   * have been cleared.
   */
  clearSourcesWithTimeout(e, t) {
    clearTimeout(b(this, _)), $(this, _, setTimeout(() => {
      this.clearSources(t);
    }, e));
  }
  /**
   * Called when a source's value is modified by the user. This method
   * should be overridden by the child class to handle these updates.
   * This method should not be called directly.
   *
   * @protected
   * @param {string} key - The source's key. This is a string separated
   * by '/'.
   * @param {*} value - The source's updated value.
   */
  userUpdate(e, t) {
    this.updateSource(e, t);
  }
  /**
   * This optional method is called when a key is subscribed to that the store does not
   * already have. A SourceProvider can override this method to update the store with
   * the requested source.
   * @Override
   * @param {string} key
   */
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function
  requestSource(e) {
  }
  /**
   * Helper function to get the type of a variable represented
   * by a string.
   *
   * @param {*} value
   * @returns {string} - The value's type.
   */
  static getType(e) {
    return typeof e == "string" ? "string" : typeof e == "number" ? "number" : typeof e == "boolean" ? "boolean" : e instanceof Array ? "Array" : e === null ? "null" : null;
  }
  addClearSourcesHandler(e) {
    const t = Symbol("clearSources");
    return b(this, U).set(t, e), () => {
      b(this, U).delete(t);
    };
  }
  addSourcesChangedHandler(e) {
    const t = Symbol("sourcesChanged");
    return b(this, I).set(t, e), () => {
      b(this, I).delete(t);
    };
  }
  addSourcesRemovedHandler(e) {
    const t = Symbol("sourcesRemoved");
    return b(this, x).set(t, e), () => {
      b(this, x).delete(t);
    };
  }
  disconnect() {
    clearTimeout(b(this, A));
  }
}
A = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakSet(), E = function(r = Y) {
  if (Object.keys(b(this, m)).length === 0) {
    r();
    return;
  }
  const e = { ...b(this, m) };
  $(this, m, {});
  const t = {}, i = {};
  Object.entries(e).forEach(([c, o]) => {
    t[c] = o.first, typeof o.last < "u" && (i[c] = o.last);
  }), v(this, k, M).call(this, t), v(this, D, R).call(this, t), Object.keys(i).length > 0 ? setTimeout(() => {
    v(this, k, M).call(this, i), v(this, D, R).call(this, i), r();
  }) : r();
}, k = /* @__PURE__ */ new WeakSet(), M = function(r) {
  const e = {};
  Object.entries(r).forEach(([t, { type: i }]) => {
    i === "change" && (e[t] = r[t].value);
  }), Object.keys(e).length > 0 && b(this, I).forEach((t) => t(e));
}, D = /* @__PURE__ */ new WeakSet(), R = function(r) {
  const e = [];
  Object.entries(r).forEach(([t, { type: i }]) => {
    i === "removal" && e.push(t);
  }), e.length > 0 && b(this, x).forEach((t) => t(e));
};
function H(r, e) {
  let t, i, c = new Uint8Array(128), o = 0;
  var h = "";
  return d(r, !1, h), c.subarray(0, o);
  function d(s, a, u) {
    switch (typeof s) {
      case "undefined":
        w();
        break;
      case "boolean":
        N(s);
        break;
      case "number":
        O(s, u);
        break;
      case "string":
        S(s);
        break;
      case "object":
        s === null ? w() : s instanceof Date ? p(s) : Array.isArray(s) ? g(s) : s instanceof Uint8Array || s instanceof Uint8ClampedArray ? F(s) : s instanceof Int8Array || s instanceof Int16Array || s instanceof Uint16Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Float32Array || s instanceof Float64Array ? g(s) : n(s);
        break;
      default:
        if (!a && e && e.invalidTypeReplacement)
          typeof e.invalidTypeReplacement == "function" || d(e.invalidTypeReplacement, !0, u);
        else
          throw new Error(
            "Invalid argument type: The type '" + typeof s + "' cannot be serialized."
          );
    }
  }
  function w(s) {
    f(192);
  }
  function N(s) {
    f(s ? 195 : 194);
  }
  function O(s, a) {
    var u = a === "int" || isFinite(s) && Math.floor(s) === s && a !== "double" && a !== "float";
    if (u)
      if (s >= 0 && s <= 127)
        f(s);
      else if (s < 0 && s >= -32)
        f(s);
      else if (s > 0 && s <= 255)
        l([204, s]);
      else if (s >= -128 && s <= 127)
        l([208, s]);
      else if (s > 0 && s <= 65535)
        l([205, s >>> 8, s]);
      else if (s >= -32768 && s <= 32767)
        l([209, s >>> 8, s]);
      else if (s > 0 && s <= 4294967295)
        l([206, s >>> 24, s >>> 16, s >>> 8, s]);
      else if (s >= -2147483648 && s <= 2147483647)
        l([210, s >>> 24, s >>> 16, s >>> 8, s]);
      else if (s > 0 && s <= 18446744073709552e3) {
        let T = s / 4294967296, j = s % 4294967296;
        l([
          211,
          T >>> 24,
          T >>> 16,
          T >>> 8,
          T,
          j >>> 24,
          j >>> 16,
          j >>> 8,
          j
        ]);
      } else
        s >= -9223372036854776e3 && s <= 9223372036854776e3 ? (f(211), L(s)) : s < 0 ? l([211, 128, 0, 0, 0, 0, 0, 0, 0]) : l([207, 255, 255, 255, 255, 255, 255, 255, 255]);
    else
      i || (t = new ArrayBuffer(8), i = new DataView(t)), i.setFloat64(0, s), f(203), l(new Uint8Array(t));
  }
  function S(s) {
    let a = ce(s), u = a.length;
    u <= 31 ? f(160 + u) : u <= 255 ? l([217, u]) : u <= 65535 ? l([218, u >>> 8, u]) : l([219, u >>> 24, u >>> 16, u >>> 8, u]), l(a);
  }
  function g(s) {
    let a = s.length;
    a <= 15 ? f(144 + a) : a <= 65535 ? l([220, a >>> 8, a]) : l([221, a >>> 24, a >>> 16, a >>> 8, a]);
    for (let u = 0; u < a; u++)
      d(s[u]);
  }
  function F(s) {
    let a = s.length;
    a <= 15 ? l([196, a]) : a <= 65535 ? l([197, a >>> 8, a]) : l([198, a >>> 24, a >>> 16, a >>> 8, a]), l(s);
  }
  function n(s) {
    let a = 0;
    for (let u in s)
      s[u] !== void 0 && a++;
    a <= 15 ? f(128 + a) : a <= 65535 ? l([222, a >>> 8, a]) : l([223, a >>> 24, a >>> 16, a >>> 8, a]);
    for (let u in s) {
      let T = s[u];
      T !== void 0 && (d(u), d(T));
    }
  }
  function p(s) {
    let a = s.getTime() / 1e3;
    if (s.getMilliseconds() === 0 && a >= 0 && a < 4294967296)
      l([214, 255, a >>> 24, a >>> 16, a >>> 8, a]);
    else if (a >= 0 && a < 17179869184) {
      let u = s.getMilliseconds() * 1e6;
      l([
        215,
        255,
        u >>> 22,
        u >>> 14,
        u >>> 6,
        u << 2 >>> 0 | a / 4294967296,
        a >>> 24,
        a >>> 16,
        a >>> 8,
        a
      ]);
    } else {
      let u = s.getMilliseconds() * 1e6;
      l([199, 12, 255, u >>> 24, u >>> 16, u >>> 8, u]), L(a);
    }
  }
  function f(s) {
    if (c.length < o + 1) {
      let a = c.length * 2;
      for (; a < o + 1; )
        a *= 2;
      let u = new Uint8Array(a);
      u.set(c), c = u;
    }
    c[o] = s, o++;
  }
  function l(s) {
    if (c.length < o + s.length) {
      let a = c.length * 2;
      for (; a < o + s.length; )
        a *= 2;
      let u = new Uint8Array(a);
      u.set(c), c = u;
    }
    c.set(s, o), o += s.length;
  }
  function L(s) {
    let a, u;
    s >= 0 ? (a = s / 4294967296, u = s % 4294967296) : (s++, a = Math.abs(s) / 4294967296, u = Math.abs(s) % 4294967296, a = ~a, u = ~u), l([
      a >>> 24,
      a >>> 16,
      a >>> 8,
      a,
      u >>> 24,
      u >>> 16,
      u >>> 8,
      u
    ]);
  }
}
function oe(r, e) {
  let t = 0;
  if (r instanceof ArrayBuffer && (r = new Uint8Array(r)), typeof r != "object" || typeof r.length > "u")
    throw new Error(
      "Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize."
    );
  if (!r.length)
    throw new Error(
      "Invalid argument: The byte array to deserialize is empty."
    );
  r instanceof Uint8Array || (r = new Uint8Array(r));
  let i;
  if (e && e.multiple)
    for (i = []; t < r.length; )
      i.push(c());
  else
    i = c();
  return i;
  function c() {
    const n = r[t++];
    if (n >= 0 && n <= 127)
      return n;
    if (n >= 128 && n <= 143)
      return N(n - 128);
    if (n >= 144 && n <= 159)
      return O(n - 144);
    if (n >= 160 && n <= 191)
      return S(n - 160);
    if (n === 192)
      return null;
    if (n === 193)
      throw new Error("Invalid byte code 0xc1 found.");
    if (n === 194)
      return !1;
    if (n === 195)
      return !0;
    if (n === 196)
      return w(-1, 1);
    if (n === 197)
      return w(-1, 2);
    if (n === 198)
      return w(-1, 4);
    if (n === 199)
      return g(-1, 1);
    if (n === 200)
      return g(-1, 2);
    if (n === 201)
      return g(-1, 4);
    if (n === 202)
      return d(4);
    if (n === 203)
      return d(8);
    if (n === 204)
      return h(1);
    if (n === 205)
      return h(2);
    if (n === 206)
      return h(4);
    if (n === 207)
      return h(8);
    if (n === 208)
      return o(1);
    if (n === 209)
      return o(2);
    if (n === 210)
      return o(4);
    if (n === 211)
      return o(8);
    if (n === 212)
      return g(1);
    if (n === 213)
      return g(2);
    if (n === 214)
      return g(4);
    if (n === 215)
      return g(8);
    if (n === 216)
      return g(16);
    if (n === 217)
      return S(-1, 1);
    if (n === 218)
      return S(-1, 2);
    if (n === 219)
      return S(-1, 4);
    if (n === 220)
      return O(-1, 2);
    if (n === 221)
      return O(-1, 4);
    if (n === 222)
      return N(-1, 2);
    if (n === 223)
      return N(-1, 4);
    if (n >= 224 && n <= 255)
      return n - 256;
    throw console.debug("msgpack array:", r), new Error(
      "Invalid byte value '" + n + "' at index " + (t - 1) + " in the MessagePack binary data (length " + r.length + "): Expecting a range of 0 to 255. This is not a byte array."
    );
  }
  function o(n) {
    let p = 0, f = !0;
    for (; n-- > 0; )
      if (f) {
        let l = r[t++];
        p += l & 127, l & 128 && (p -= 128), f = !1;
      } else
        p *= 256, p += r[t++];
    return p;
  }
  function h(n) {
    let p = 0;
    for (; n-- > 0; )
      p *= 256, p += r[t++];
    return p;
  }
  function d(n) {
    let p = new DataView(r.buffer, t + r.byteOffset, n);
    if (t += n, n === 4)
      return p.getFloat32(0, !1);
    if (n === 8)
      return p.getFloat64(0, !1);
  }
  function w(n, p) {
    n < 0 && (n = h(p));
    let f = r.subarray(t, t + n);
    return t += n, f;
  }
  function N(n, p) {
    n < 0 && (n = h(p));
    let f = {};
    for (; n-- > 0; ) {
      let l = c();
      f[l] = c();
    }
    return f;
  }
  function O(n, p) {
    n < 0 && (n = h(p));
    let f = [];
    for (; n-- > 0; )
      f.push(c());
    return f;
  }
  function S(n, p) {
    n < 0 && (n = h(p));
    let f = t;
    return t += n, ae(r, f, n);
  }
  function g(n, p) {
    n < 0 && (n = h(p));
    let f = h(1), l = w(n);
    switch (f) {
      case 255:
        return F(l);
    }
    return { type: f, data: l };
  }
  function F(n) {
    if (n.length === 4) {
      let p = (n[0] << 24 >>> 0) + (n[1] << 16 >>> 0) + (n[2] << 8 >>> 0) + n[3];
      return new Date(p * 1e3);
    }
    if (n.length === 8) {
      let p = (n[0] << 22 >>> 0) + (n[1] << 14 >>> 0) + (n[2] << 6 >>> 0) + (n[3] >>> 2), f = (n[3] & 3) * 4294967296 + (n[4] << 24 >>> 0) + (n[5] << 16 >>> 0) + (n[6] << 8 >>> 0) + n[7];
      return new Date(f * 1e3 + p / 1e6);
    }
    if (n.length === 12) {
      let p = (n[0] << 24 >>> 0) + (n[1] << 16 >>> 0) + (n[2] << 8 >>> 0) + n[3];
      t -= 8;
      let f = o(8);
      return new Date(f * 1e3 + p / 1e6);
    }
    throw new Error("Invalid data length for a date value.");
  }
}
function ce(r) {
  let e = !0, t = r.length;
  for (let o = 0; o < t; o++)
    if (r.charCodeAt(o) > 127) {
      e = !1;
      break;
    }
  let i = 0, c = new Uint8Array(r.length * (e ? 1 : 4));
  for (let o = 0; o !== t; o++) {
    let h = r.charCodeAt(o);
    if (h < 128) {
      c[i++] = h;
      continue;
    }
    if (h < 2048)
      c[i++] = h >> 6 | 192;
    else {
      if (h > 55295 && h < 56320) {
        if (++o >= t)
          throw new Error("UTF-8 encode: incomplete surrogate pair");
        let d = r.charCodeAt(o);
        if (d < 56320 || d > 57343)
          throw new Error(
            "UTF-8 encode: second surrogate character 0x" + d.toString(16) + " at index " + o + " out of range"
          );
        h = 65536 + ((h & 1023) << 10) + (d & 1023), c[i++] = h >> 18 | 240, c[i++] = h >> 12 & 63 | 128;
      } else
        c[i++] = h >> 12 | 224;
      c[i++] = h >> 6 & 63 | 128;
    }
    c[i++] = h & 63 | 128;
  }
  return e ? c : c.subarray(0, i);
}
function ae(r, e, t) {
  let i = e, c = "";
  for (t += e; i < t; ) {
    let o = r[i++];
    if (o > 127)
      if (o > 191 && o < 224) {
        if (i >= t)
          throw new Error("UTF-8 decode: incomplete 2-byte sequence");
        o = (o & 31) << 6 | r[i++] & 63;
      } else if (o > 223 && o < 240) {
        if (i + 1 >= t)
          throw new Error("UTF-8 decode: incomplete 3-byte sequence");
        o = (o & 15) << 12 | (r[i++] & 63) << 6 | r[i++] & 63;
      } else if (o > 239 && o < 248) {
        if (i + 2 >= t)
          throw new Error("UTF-8 decode: incomplete 4-byte sequence");
        o = (o & 7) << 18 | (r[i++] & 63) << 12 | (r[i++] & 63) << 6 | r[i++] & 63;
      } else
        throw new Error(
          "UTF-8 decode: unknown multibyte start 0x" + o.toString(16) + " at index " + (i - 1)
        );
    if (o <= 65535)
      c += String.fromCharCode(o);
    else if (o <= 1114111)
      o -= 65536, c += String.fromCharCode(o >> 10 | 55296), c += String.fromCharCode(o & 1023 | 56320);
    else
      throw new Error(
        "UTF-8 decode: code point 0x" + o.toString(16) + " exceeds UTF-16 reach"
      );
  }
  return c;
}
const W = {
  boolean: 0,
  double: 1,
  int: 2,
  float: 3,
  string: 4,
  json: 4,
  raw: 5,
  rpc: 5,
  msgpack: 5,
  protobuf: 5,
  "boolean[]": 16,
  "double[]": 17,
  "int[]": 18,
  "float[]": 19,
  "string[]": 20
};
class P {
  constructor() {
    this.uid = -1, this.topics = /* @__PURE__ */ new Set(), this.options = new he();
  }
  toSubscribeObj() {
    return {
      topics: Array.from(this.topics),
      subuid: this.uid,
      options: this.options.toObj()
    };
  }
  toUnsubscribeObj() {
    return {
      subuid: this.uid
    };
  }
}
class he {
  constructor() {
    this.periodic = 0.02, this.all = !1, this.topicsOnly = !1, this.prefix = !1;
  }
  toObj() {
    return {
      periodic: this.periodic,
      all: this.all,
      topicsonly: this.topicsOnly,
      prefix: this.prefix
    };
  }
}
class z {
  constructor() {
    this.uid = -1, this.name = "", this.type = "", this.properties = {};
  }
  toPublishObj() {
    return {
      name: this.name,
      type: this.type,
      pubuid: this.uid,
      properties: this.properties
    };
  }
  toUnpublishObj() {
    return {
      pubuid: this.uid
    };
  }
  getTypeIdx() {
    return this.type in W ? W[this.type] : 5;
  }
}
class ue {
  /**
   * Creates a new NT4 client without connecting.
   * @param serverAddr Network address of NT4 server
   * @param appName Identifier for this client (does not need to be unique).
   * @param onTopicAnnounce Gets called when server announces enough topics to form a new signal
   * @param onTopicUnannounce Gets called when server unannounces any part of a signal
   * @param onNewTopicData Gets called when any new data is available
   * @param onConnect Gets called once client completes initial handshake with server
   * @param onDisconnect Gets called once client detects server has disconnected
   */
  constructor(e, t, i, c, o, h, d) {
    this.ws = null, this.clientIdx = 0, this.useSecure = !1, this.serverAddr = "", this.serverConnectionActive = !1, this.serverConnectionRequested = !1, this.serverTimeOffset_us = null, this.uidCounter = 0, this.subscriptions = /* @__PURE__ */ new Map(), this.publishedTopics = /* @__PURE__ */ new Map(), this.serverTopics = /* @__PURE__ */ new Map(), this.serverBaseAddr = e, this.appName = t, this.onTopicAnnounce = i, this.onTopicUnannounce = c, this.onNewTopicData = o, this.onConnect = h, this.onDisconnect = d, setInterval(() => this.ws_sendTimestamp(), 5e3);
  }
  //////////////////////////////////////////////////////////////
  // PUBLIC API
  /** Starts the connection. The client will reconnect automatically when disconnected. */
  connect() {
    this.serverConnectionRequested || (this.serverConnectionRequested = !0, this.ws_connect());
  }
  /** Terminates the connection. */
  disconnect() {
    this.serverConnectionRequested && (this.serverConnectionRequested = !1, this.serverConnectionActive && this.ws && this.ws.close());
  }
  /**
   * Add a new subscription, reading data at the specified frequency.
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @param period The period to return data in seconds.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribePeriodic(e, t, i) {
    let c = new P();
    return c.uid = this.getNewUID(), c.topics = new Set(e), c.options.prefix = t, c.options.periodic = i, this.subscriptions.set(c.uid, c), this.serverConnectionActive && this.ws_subscribe(c), c.uid;
  }
  /**
   * Add a new subscription, reading all value updates.
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribeAll(e, t) {
    let i = new P();
    return i.uid = this.getNewUID(), i.topics = new Set(e), i.options.prefix = t, i.options.all = !0, this.subscriptions.set(i.uid, i), this.serverConnectionActive && this.ws_subscribe(i), i.uid;
  }
  /**
   * Add a new subscription, reading only topic announcements (not values).
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribeTopicsOnly(e, t) {
    let i = new P();
    return i.uid = this.getNewUID(), i.topics = new Set(e), i.options.prefix = t, i.options.topicsOnly = !0, this.subscriptions.set(i.uid, i), this.serverConnectionActive && this.ws_subscribe(i), i.uid;
  }
  /** Given an existing subscription, unsubscribe from it. */
  unsubscribe(e) {
    let t = this.subscriptions.get(e);
    if (!t)
      throw 'Unknown subscription ID "' + e + '"';
    this.subscriptions.delete(e), this.serverConnectionActive && this.ws_unsubscribe(t);
  }
  /** Unsubscribe from all current subscriptions. */
  clearAllSubscriptions() {
    for (const e of this.subscriptions.keys())
      this.unsubscribe(e);
  }
  /**
   * Set the properties of a particular topic.
   * @param topic The topic to update
   * @param properties The set of new properties
   */
  setProperties(e, t) {
    let i = (h) => {
      for (const d of Object.keys(t)) {
        let w = t[d];
        w === null ? delete h.properties[d] : h.properties[d] = w;
      }
    }, c = this.publishedTopics.get(e);
    c && i(c);
    let o = this.serverTopics.get(e);
    o && i(o), this.serverConnectionActive && this.ws_setproperties(e, t);
  }
  /** Set whether a topic is persistent.
   *
   * If true, the last set value will be periodically saved to
   * persistent storage on the server and be restored during server
   * startup. Topics with this property set to true will not be
   * deleted by the server when the last publisher stops publishing.
   */
  setPersistent(e, t) {
    this.setProperties(e, { persistent: t });
  }
  /** Set whether a topic is retained.
   *
   * Topics with this property set to true will not be deleted by
   * the server when the last publisher stops publishing.
   */
  setRetained(e, t) {
    this.setProperties(e, { retained: t });
  }
  /** Publish a new topic from this client with the provided name and type. */
  publishNewTopic(e, t) {
    if (this.publishedTopics.has(e))
      return;
    let i = new z();
    i.name = e, i.uid = this.getNewUID(), i.type = t, this.publishedTopics.set(e, i), this.serverConnectionActive && this.ws_publish(i);
  }
  /** Unpublish a previously-published topic from this client. */
  unpublishTopic(e) {
    let t = this.publishedTopics.get(e);
    if (!t)
      throw 'Topic "' + e + '" not found';
    this.publishedTopics.delete(e), this.serverConnectionActive && this.ws_unpublish(t);
  }
  /** Send some new value to the server. The timestamp is whatever the current time is. */
  addSample(e, t) {
    let i = this.getServerTime_us();
    i === null && (i = 0), this.addTimestampedSample(e, i, t);
  }
  /** Send some new timestamped value to the server. */
  addTimestampedSample(e, t, i) {
    let c = this.publishedTopics.get(e);
    if (!c)
      throw 'Topic "' + e + '" not found';
    let o = H([
      c.uid,
      t,
      c.getTypeIdx(),
      i
    ]);
    this.ws_sendBinary(o);
  }
  //////////////////////////////////////////////////////////////
  // Server/Client Time Sync Handling
  /** Returns the current client time in microseconds. */
  getClientTime_us() {
    return (/* @__PURE__ */ new Date()).getTime() * 1e3;
  }
  /** Returns the current server time in microseconds (or null if unknown). */
  getServerTime_us() {
    return this.serverTimeOffset_us === null ? null : this.getClientTime_us() + this.serverTimeOffset_us;
  }
  ws_sendTimestamp() {
    let e = this.getClientTime_us(), t = H([-1, 0, W.int, e]);
    this.ws_sendBinary(t);
  }
  ws_handleReceiveTimestamp(e, t) {
    let i = this.getClientTime_us(), c = i - t, o = e + c / 2;
    this.serverTimeOffset_us = o - i, console.log(
      "[NT4] New server time estimate: " + (this.getServerTime_us() / 1e6).toString()
    );
  }
  //////////////////////////////////////////////////////////////
  // Websocket Message Send Handlers
  ws_subscribe(e) {
    this.ws_sendJSON("subscribe", e.toSubscribeObj());
  }
  ws_unsubscribe(e) {
    this.ws_sendJSON("unsubscribe", e.toUnsubscribeObj());
  }
  ws_publish(e) {
    this.ws_sendJSON("publish", e.toPublishObj());
  }
  ws_unpublish(e) {
    this.ws_sendJSON("unpublish", e.toUnpublishObj());
  }
  ws_setproperties(e, t) {
    this.ws_sendJSON("setproperties", {
      name: e,
      update: t
    });
  }
  ws_sendJSON(e, t) {
    this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(
      JSON.stringify([
        {
          method: e,
          params: t
        }
      ])
    );
  }
  ws_sendBinary(e) {
    this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(e);
  }
  //////////////////////////////////////////////////////////////
  // Websocket connection Maintenance
  ws_onOpen() {
    this.serverConnectionActive = !0, console.log("[NT4] Connected with idx " + this.clientIdx.toString()), this.ws_sendTimestamp();
    for (const e of this.publishedTopics.values())
      this.ws_publish(e);
    for (const e of this.subscriptions.values())
      this.ws_subscribe(e);
    this.onConnect();
  }
  ws_onClose(e) {
    this.ws = null, this.serverConnectionActive = !1, this.onDisconnect(), this.serverTopics.clear(), e.reason !== "" && console.log("[NT4] Socket is closed: ", e.reason), this.serverConnectionRequested && setTimeout(() => this.ws_connect(), 500);
  }
  ws_onError() {
    this.ws && this.ws.close();
  }
  ws_onMessage(e) {
    if (typeof e.data == "string") {
      let t = JSON.parse(e.data);
      if (!Array.isArray(t)) {
        console.warn(
          "[NT4] Ignoring text message, JSON parsing did not produce an array at the top level."
        );
        return;
      }
      t.forEach((i) => {
        if (typeof i != "object") {
          console.warn(
            "[NT4] Ignoring text message, JSON parsing did not produce an object."
          );
          return;
        }
        if (!("method" in i) || !("params" in i)) {
          console.warn(
            "[NT4] Ignoring text message, JSON parsing did not find all required fields."
          );
          return;
        }
        let c = i.method, o = i.params;
        if (typeof c != "string") {
          console.warn(
            `[NT4] Ignoring text message, JSON parsing found "method", but it wasn't a string.`
          );
          return;
        }
        if (typeof o != "object") {
          console.warn(
            `[NT4] Ignoring text message, JSON parsing found "params", but it wasn't an object.`
          );
          return;
        }
        if (c === "announce") {
          let h = new z();
          h.uid = o.id, h.name = o.name, h.type = o.type, h.properties = o.properties, this.serverTopics.set(h.name, h), this.onTopicAnnounce(h);
        } else if (c === "unannounce") {
          let h = this.serverTopics.get(o.name);
          if (!h) {
            console.warn(
              "[NT4] Ignoring unannounce, topic was not previously announced."
            );
            return;
          }
          this.serverTopics.delete(h.name), this.onTopicUnannounce(h);
        } else if (c === "properties") {
          let h = this.serverTopics.get(o.name);
          if (!h) {
            console.warn(
              "[NT4] Ignoring set properties, topic was not previously announced."
            );
            return;
          }
          for (const d of Object.keys(o.update)) {
            let w = o.update[d];
            w === null ? delete h.properties[d] : h.properties[d] = w;
          }
        } else {
          console.warn(
            "[NT4] Ignoring text message - unknown method " + c
          );
          return;
        }
      });
    } else
      oe(e.data, { multiple: !0 }).forEach(
        (t) => {
          let i = t[0], c = t[1], o = t[3];
          if (i >= 0) {
            let h = null;
            for (let d of this.serverTopics.values())
              d.uid === i && (h = d);
            if (!h) {
              console.warn(
                "[NT4] Ignoring binary data - unknown topic ID " + i.toString()
              );
              return;
            }
            this.onNewTopicData(h, c, o);
          } else
            i === -1 ? this.ws_handleReceiveTimestamp(c, o) : console.warn(
              "[NT4] Ignoring binary data - invalid topic ID " + i.toString()
            );
        }
      );
  }
  ws_connect() {
    this.clientIdx = Math.floor(Math.random() * 99999999);
    let e = 5810, t = "ws://";
    this.useSecure && (t = "wss://", e = 5811), this.serverAddr = t + this.serverBaseAddr + ":" + e.toString() + "/nt/" + this.appName + "_" + this.clientIdx.toString(), this.ws = new WebSocket(this.serverAddr, "networktables.first.wpi.edu"), this.ws.binaryType = "arraybuffer", this.ws.addEventListener("open", () => this.ws_onOpen()), this.ws.addEventListener(
      "message",
      (i) => this.ws_onMessage(i)
    ), this.ws.addEventListener(
      "close",
      (i) => this.ws_onClose(i)
    ), this.ws.addEventListener("error", () => this.ws_onError());
  }
  //////////////////////////////////////////////////////////////
  // General utilties
  getNewUID() {
    return this.uidCounter++, this.uidCounter + this.clientIdx;
  }
}
function J(r) {
  if (typeof r == "boolean" || typeof r == "string")
    return typeof r;
  if (typeof r == "number")
    return "double";
  if (r instanceof Array) {
    if (r.length === 0)
      return;
    const e = J(r[0]);
    return r.some((t) => J(t) !== e) ? void 0 : `${e}[]`;
  }
}
function le(r) {
  const e = r.toString().at(-4) ?? "", t = r.toString().at(-3) ?? "", i = r.toString().at(-2) ?? "", c = r.toString().at(-1) ?? "";
  let o = parseInt(`${e}${t}`, 10), h = parseInt(`${i}${c}`, 10);
  Number.isNaN(o) && (o = 0), Number.isNaN(h) && (h = 0);
  const d = e + t + i + c;
  return [
    `10.${o.toString()}.${h.toString()}.2`,
    "172.22.11.2",
    `roborio-${d}-FRC.local`,
    `roborio-${d}-FRC.lan`,
    `roborio-${d}-FRC.frc-field.local`
  ];
}
class de extends re {
  constructor() {
    super({}, 1e3 / 60), this.serverAddress = "", this.clients = {}, this.connected = !1, this.topics = {}, this.topicValues = {}, this.unprocessedUpdates = {}, this.connectionListeners = [], this.connect(localStorage.getItem("nt4Address") ?? "127.0.0.1");
  }
  setValue(e, t) {
    this.userUpdate(e, t);
  }
  getValue(e, t) {
    return e in this.topicValues ? this.topicValues[e] : t;
  }
  getServerAddress() {
    return this.serverAddress;
  }
  connect(e) {
    this.serverAddress !== e && (this.clearSources(), this.createClient(e));
  }
  disconnect() {
    var e;
    (e = this.client) == null || e.disconnect();
  }
  isConnected() {
    return this.connected;
  }
  addConnectionListener(e, t = !1) {
    this.connectionListeners.push(e), t && e(this.connected, this.serverAddress);
  }
  processUnprocessedUpdates() {
    const e = { ...this.unprocessedUpdates };
    this.unprocessedUpdates = {}, Object.entries(e).forEach(([t, i]) => {
      this.userUpdate(t, i);
    });
  }
  // TODO: Be able to optionally pass in additional data
  userUpdate(e, t) {
    if (!this.client) {
      this.unprocessedUpdates[e] = t;
      return;
    }
    const i = this.topics[e];
    if (i)
      this.client.publishNewTopic(i.name, i.type), this.client.addSample(i.name, t), this.updateSource(i.name, t);
    else {
      const c = J(t);
      c !== void 0 && (this.client.publishNewTopic(e, c), this.client.addSample(e, t), this.updateSource(e, t));
    }
  }
  onTopicAnnounce(e) {
    this.topics[e.name] = e;
  }
  onTopicUnannounce(e) {
    delete this.topics[e.name], delete this.topicValues[e.name], this.removeSource(e.name);
  }
  onNewTopicData(e, t, i) {
    this.updateSource(e.name, i), this.topicValues[e.name] = i;
  }
  onConnect() {
    this.connected = !0, this.connectionListeners.forEach(
      (e) => e(!0, this.serverAddress)
    ), this.processUnprocessedUpdates();
  }
  onDisconnect() {
    this.connected = !1, this.connectionListeners.forEach(
      (e) => e(!1, this.serverAddress)
    );
  }
  createClient(e) {
    this.client && (this.client.disconnect(), this.topics = {}, this.topicValues = {}, this.connected = !1, this.client = void 0), Object.values(this.clients).forEach((i) => i.disconnect()), this.clients = {}, this.serverAddress = e, this.connectionListeners.forEach(
      (i) => i(this.connected, this.serverAddress)
    ), localStorage.setItem("nt4Address", e);
    const t = "FRC Web Components";
    (/^[0-9]+$/.test(e) && !Number.isNaN(parseFloat(e)) ? le(parseFloat(e)) : [e]).forEach((i) => {
      const c = new ue(
        i,
        t,
        (...o) => {
          this.client === c && this.onTopicAnnounce(...o);
        },
        (...o) => {
          this.client === c && this.onTopicUnannounce(...o);
        },
        (...o) => {
          this.client === c && this.onNewTopicData(...o);
        },
        () => {
          this.client = c, Object.entries(this.clients).forEach(
            ([o, h]) => {
              o !== i && h.disconnect();
            }
          ), this.clients = {}, this.onConnect();
        },
        () => {
          this.client === c && this.onDisconnect();
        }
      );
      this.clients[i] = c, c.connect(), c.subscribeAll(["/"], !0);
    });
  }
}
const G = Q(void 0);
function pe(r) {
  const e = new ee(document.body), t = new de();
  return e.addSourceProvider("NetworkTables", t), e.setDefaultSourceProvider("NetworkTables"), e.addElements(te, "FRC"), t.connect(r), { store: e.getStore(), nt4Provider: t };
}
const ge = ({
  children: r,
  address: e
}) => {
  const [{ store: t, nt4Provider: i }] = X(() => pe(e));
  return /* @__PURE__ */ K(G.Provider, { value: { store: t, nt4Provider: i }, children: r });
}, me = () => {
  const r = Z(G);
  if (!r)
    throw new Error("useStore must be used within a StoreProvider");
  return r;
};
export {
  ge as N,
  me as u
};
