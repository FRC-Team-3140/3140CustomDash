import E from "react";
import { U as R, M as i, H as k, O as j, d as X, o as O } from "../property-C4BPH-wS-7fb0a59c.js";
import { h as Z, i as tt } from "../query-BrpQj_Qi-db00b239.js";
import { n as J } from "../state-Cn3aen3G-6b8e5a08.js";
import { i as et, o as rt } from "../index-BXxACewW-cecd5a05.js";
import { T as it, _ as st } from "../directive-B76A7YXI-abc0af54.js";
import { f as ot } from "../directive-helpers-CDfQTKPA-206aa42d.js";
import "../_commonjsHelpers-DaMA6jEr-bedfce41.js";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let Y;
function at(s) {
  return (t, r) => tt(t, r, { get() {
    return (this.renderRoot ?? Y ?? (Y = document.createDocumentFragment())).querySelectorAll(s);
  } });
}
var nt = Object.defineProperty, A = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && nt(t, r, e), e;
};
class C extends k {
  constructor() {
    super(...arguments), this.points = [], this.opacity = 1, this.color = null, this.lineWidth = 2, this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["left", "top"], this.zIndex = 0, this._points = [];
  }
  updated(t) {
    t.has("points") && (this._points = et(this.points, 2));
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), t.lineWidth = this.lineWidth ?? 2, t.strokeStyle = this.color ?? "gray";
    const [r, a, e] = this.transform ?? [
      0,
      0,
      0
    ];
    t.translate(r, a);
    const [o, n] = this.transformOrigin ?? [0, 0], l = o, h = n;
    if (t.translate(l, h), t.rotate(-(e * Math.PI) / 180), t.translate(-l, -h), this._points.length > 1) {
      for (let c = 0; c < this._points.length - 1; c += 1) {
        const [v, d] = this._points[c], [p, P] = this._points[c + 1];
        t.moveTo(v, d), t.lineTo(p, P);
      }
      t.stroke();
    }
  }
}
A([
  i({ type: Array })
], C.prototype, "points");
A([
  i({ type: Number })
], C.prototype, "opacity");
A([
  i({ type: String })
], C.prototype, "color");
A([
  i({ type: Number, attribute: "line-width" })
], C.prototype, "lineWidth");
A([
  i({ type: Array })
], C.prototype, "transform");
A([
  i({ type: Array, attribute: "transform-origin" })
], C.prototype, "transformOrigin");
A([
  i({ type: Array, attribute: "draw-origin" })
], C.prototype, "drawOrigin");
A([
  i({ type: Array, attribute: "z-index" })
], C.prototype, "zIndex");
A([
  J()
], C.prototype, "_points");
customElements.get("frc-canvas-line") || customElements.define("frc-canvas-line", C);
var ht = Object.defineProperty, w = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && ht(t, r, e), e;
};
class m extends k {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.width = 10, this.height = 10, this.radii = 0, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, a] = this.origin;
    const [e, o] = this.drawOrigin ?? ["center", "center"];
    e === "center" ? r -= this.width / 2 : e === "right" && (r -= this.width), o === "center" ? a -= this.height / 2 : o === "bottom" && (a -= this.height);
    const [n, l, h] = this.transform ?? [
      0,
      0,
      0
    ];
    r += n, a += l, t.translate(r, a);
    const [c, v] = this.transformOrigin ?? [0, 0], d = c + this.width / 2, p = v + this.height / 2;
    t.translate(d, p), t.rotate(-(h * Math.PI) / 180), t.translate(-d, -p), t.roundRect(0, 0, this.width, this.height, this.radii), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
w([
  i({ type: Array })
], m.prototype, "origin");
w([
  i({ type: Number })
], m.prototype, "width");
w([
  i({ type: Number })
], m.prototype, "height");
w([
  i({ type: Number })
], m.prototype, "radii");
w([
  i({ type: Number })
], m.prototype, "opacity");
w([
  i({ type: String, attribute: "stroke-color" })
], m.prototype, "strokeColor");
w([
  i({ type: Number, attribute: "stroke-width" })
], m.prototype, "strokeWidth");
w([
  i({ type: String, attribute: "fill-color" })
], m.prototype, "fillColor");
w([
  i({ type: Array })
], m.prototype, "transform");
w([
  i({ type: Array, attribute: "transform-origin" })
], m.prototype, "transformOrigin");
w([
  i({ type: Array, attribute: "draw-origin" })
], m.prototype, "drawOrigin");
w([
  i({ type: Array, attribute: "z-index" })
], m.prototype, "zIndex");
customElements.get("frc-canvas-rect") || customElements.define("frc-canvas-rect", m);
var ct = Object.defineProperty, b = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && ct(t, r, e), e;
};
class y extends k {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.radius = 10, this.startAngle = 0, this.endAngle = 360, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, a] = this.origin;
    const [e, o] = this.drawOrigin ?? ["center", "center"];
    e === "left" ? r += this.radius : e === "right" && (r -= this.radius), o === "top" ? a += this.radius : o === "bottom" && (a -= this.radius);
    const [n, l, h] = this.transform ?? [
      0,
      0,
      0
    ];
    r += n, a += l, t.translate(r, a);
    const [c, v] = this.transformOrigin ?? [0, 0], d = c, p = v;
    t.translate(d, p), t.rotate(-(h * Math.PI) / 180), t.translate(-d, -p), t.beginPath(), t.arc(
      0,
      0,
      this.radius,
      -(this.startAngle ?? 0) * Math.PI / 180,
      -(this.endAngle ?? 360) * Math.PI / 180,
      !0
    ), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
b([
  i({ type: Array })
], y.prototype, "origin");
b([
  i({ type: Number })
], y.prototype, "radius");
b([
  i({ type: Number, attribute: "start-angle" })
], y.prototype, "startAngle");
b([
  i({ type: Number, attribute: "end-angle" })
], y.prototype, "endAngle");
b([
  i({ type: Number })
], y.prototype, "opacity");
b([
  i({ type: String, attribute: "stroke-color" })
], y.prototype, "strokeColor");
b([
  i({ type: Number, attribute: "stroke-width" })
], y.prototype, "strokeWidth");
b([
  i({ type: String, attribute: "fill-color" })
], y.prototype, "fillColor");
b([
  i({ type: Array })
], y.prototype, "transform");
b([
  i({ type: Array, attribute: "transform-origin" })
], y.prototype, "transformOrigin");
b([
  i({ type: Array, attribute: "draw-origin" })
], y.prototype, "drawOrigin");
b([
  i({ type: Array, attribute: "z-index" })
], y.prototype, "zIndex");
customElements.get("frc-canvas-circle") || customElements.define("frc-canvas-circle", y);
var lt = Object.defineProperty, x = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && lt(t, r, e), e;
};
class u extends k {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.sides = 5, this.radius = 10, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, a] = this.origin;
    const [e, o] = this.drawOrigin ?? ["center", "center"];
    e === "left" ? r += this.radius : e === "right" && (r -= this.radius), o === "top" ? a += this.radius : o === "bottom" && (a -= this.radius);
    const [n, l, h] = this.transform ?? [
      0,
      0,
      0
    ];
    r += n, a += l, t.translate(r, a);
    const [c, v] = this.transformOrigin ?? [0, 0], d = c, p = v;
    if (t.translate(d, p), t.rotate(-(h * Math.PI) / 180), t.translate(-d, -p), this.sides < 3)
      return;
    const P = Math.PI * 2 / this.sides;
    t.beginPath();
    for (let T = 0; T < this.sides; T += 1) {
      const _ = T * P, W = this.radius * Math.cos(_), q = this.radius * Math.sin(_);
      T === 0 ? t.moveTo(W, q) : t.lineTo(W, q);
    }
    t.closePath(), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
x([
  i({ type: Array })
], u.prototype, "origin");
x([
  i({ type: Number })
], u.prototype, "sides");
x([
  i({ type: Number })
], u.prototype, "radius");
x([
  i({ type: Number })
], u.prototype, "opacity");
x([
  i({ type: String, attribute: "stroke-color" })
], u.prototype, "strokeColor");
x([
  i({ type: Number, attribute: "stroke-width" })
], u.prototype, "strokeWidth");
x([
  i({ type: String, attribute: "fill-color" })
], u.prototype, "fillColor");
x([
  i({ type: Array })
], u.prototype, "transform");
x([
  i({ type: Array, attribute: "transform-origin" })
], u.prototype, "transformOrigin");
x([
  i({ type: Array, attribute: "draw-origin" })
], u.prototype, "drawOrigin");
x([
  i({ type: Array, attribute: "z-index" })
], u.prototype, "zIndex");
customElements.get("frc-canvas-ngon") || customElements.define("frc-canvas-ngon", u);
var dt = Object.defineProperty, F = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && dt(t, r, e), e;
};
class $ extends k {
  constructor() {
    super(...arguments), this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.zIndex = 0;
  }
  draw(t) {
    const { ctx: r } = t, [a, e, o] = this.transform ?? [
      0,
      0,
      0
    ];
    r.translate(a, e);
    const [n, l] = this.transformOrigin ?? [0, 0], h = n, c = l;
    r.translate(h, c), r.rotate(-(o * Math.PI) / 180), r.translate(-h, -c), [...this.children].forEach((v) => {
      var d;
      r.save(), r.beginPath();
      const p = v;
      (d = p.draw) == null || d.call(p, t), r.restore();
    });
  }
}
F([
  i({ type: Array })
], $.prototype, "transform");
F([
  i({ type: Array, attribute: "transform-origin" })
], $.prototype, "transformOrigin");
F([
  i({ type: Array, attribute: "z-index" })
], $.prototype, "zIndex");
customElements.get("frc-canvas-group") || customElements.define("frc-canvas-group", $);
var pt = Object.defineProperty, f = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && pt(t, r, e), e;
};
class g extends k {
  constructor() {
    super(...arguments), this.text = "", this.origin = [0, 0], this.maxWidth = null, this.fontName = "sans-serif", this.fontSize = 12, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity ?? 1)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor), t.textAlign = "center", t.textBaseline = "middle", t.font = `${this.fontSize ?? 12}px ${this.fontName || "sans-serif"}`;
    let [r, a] = this.origin ?? [0, 0];
    const { width: e, actualBoundingBoxAscent: o, actualBoundingBoxDescent: n } = t.measureText(this.text ?? ""), l = o + n, [h, c] = this.drawOrigin ?? ["center", "center"];
    h === "left" ? r += e / 2 : h === "right" && (r -= e / 2), c === "top" ? a += l / 2 : c === "bottom" && (a -= l / 2);
    const [v, d, p] = this.transform ?? [
      0,
      0,
      0
    ];
    r += v, a += d, t.translate(r, a);
    const [P, T] = this.transformOrigin ?? [0, 0], _ = P, W = T;
    t.translate(_, W), t.rotate(-(p * Math.PI) / 180), t.translate(-_, -W), this.fillColor && t.fillText(this.text ?? "", 0, 0), this.strokeColor && (t.lineWidth = this.strokeWidth ?? 2, t.strokeText(this.text ?? "", 0, 0));
  }
}
f([
  i({ type: String })
], g.prototype, "text");
f([
  i({ type: Array })
], g.prototype, "origin");
f([
  i({ type: Number, attribute: "max-width" })
], g.prototype, "maxWidth");
f([
  i({ type: String, attribute: "font-name" })
], g.prototype, "fontName");
f([
  i({ type: Number, attribute: "font-size" })
], g.prototype, "fontSize");
f([
  i({ type: Number })
], g.prototype, "opacity");
f([
  i({ type: String, attribute: "stroke-color" })
], g.prototype, "strokeColor");
f([
  i({ type: Number, attribute: "stroke-width" })
], g.prototype, "strokeWidth");
f([
  i({ type: String, attribute: "fill-color" })
], g.prototype, "fillColor");
f([
  i({ type: Array })
], g.prototype, "transform");
f([
  i({ type: Array, attribute: "transform-origin" })
], g.prototype, "transformOrigin");
f([
  i({ type: Array, attribute: "draw-origin" })
], g.prototype, "drawOrigin");
f([
  i({ type: Array, attribute: "z-index" })
], g.prototype, "zIndex");
customElements.get("frc-canvas-text") || customElements.define("frc-canvas-text", g);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const gt = it(class extends st {
  constructor() {
    super(...arguments), this.key = X;
  }
  render(s, t) {
    return this.key = s, t;
  }
  update(s, [t, r]) {
    return t !== this.key && (ot(s), this.key = t), r;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const D = (s) => s ?? X;
var mt = Object.defineProperty, z = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && mt(t, r, e), e;
};
const K = class extends k {
  constructor() {
    super(...arguments), this.src = "", this.width = null, this.height = null, this.origin = [0, 0], this.disabled = !1, this.hideCrosshair = !1, this.crosshairColor = "white", this.image = new Image(), this.connected = !1, this.throttleUpdateImage = rt(() => this.updateImage(), 5e3), this.onImageLoadBound = this.onImageLoad.bind(this), this.onImageErrorBound = this.onImageError.bind(this);
  }
  getImageSize(t) {
    const r = {
      width: this.width || t.width,
      height: this.height || t.height
    };
    return this.image.height / this.image.width * r.width > r.height ? {
      height: r.height,
      width: this.image.width / this.image.height * r.height
    } : {
      height: this.image.height / this.image.width * r.width,
      width: r.width
    };
  }
  draw({ ctx: t, canvas: r }) {
    const { width: a, height: e } = this.getImageSize(r), o = {
      width: this.width || r.width,
      height: this.height || r.height
    }, [n, l] = this.origin ?? [0, 0];
    if (t.translate(n, l), !!this.connected)
      try {
        const h = (o.width - a) / 2, c = (o.height - e) / 2;
        t.drawImage(this.image, h, c, a, e), this.hideCrosshair || (t.strokeStyle = this.crosshairColor || "white", t.lineWidth = 1, t.beginPath(), t.setLineDash([7, 7]), t.moveTo(h, c + e / 2), t.lineTo(h + a, c + e / 2), t.stroke(), t.beginPath(), t.setLineDash([5, 5]), t.moveTo(h + a / 2, c), t.lineTo(h + a / 2, c + e), t.stroke());
      } catch {
        this.throttleUpdateImage();
      }
  }
  disconnectedCallback() {
    super.disconnectedCallback(), clearTimeout(this.loadedTimeout), this.image.src = "";
  }
  connectedCallback() {
    super.connectedCallback(), this.throttleUpdateImage();
  }
  isImageLoaded() {
    return this.image.complete && this.image.naturalHeight !== 0;
  }
  updateImage() {
    if (clearTimeout(this.loadedTimeout), !this.disabled) {
      if (!this.isConnected) {
        this.setConnected(!1);
        return;
      }
      this.isImageLoaded() || (this.loadedTimeout = setTimeout(() => {
        this.throttleUpdateImage();
      }, 5e3), this.image.removeEventListener("load", this.onImageLoadBound), this.image.removeEventListener("error", this.onImageErrorBound), this.image.src = "", this.image = new Image(), this.setConnected(!1), this.image.src = this.src ?? "", this.image.addEventListener("load", this.onImageLoadBound), this.image.addEventListener("error", this.onImageErrorBound));
    }
  }
  setConnected(t) {
    this.connected && !t ? (this.connected = !1, this.dispatchDisconnect()) : !this.connected && t && (this.connected = !0, this.dispatchConnect());
  }
  onImageLoad() {
    this.setConnected(!0), clearTimeout(this.loadedTimeout);
  }
  onImageError() {
    this.throttleUpdateImage();
  }
  dispatchConnect() {
    this.dispatchEvent(
      new CustomEvent("connect", {
        bubbles: !0,
        composed: !0
      })
    );
  }
  dispatchDisconnect() {
    this.dispatchEvent(
      new CustomEvent("disconnect", {
        bubbles: !0,
        composed: !0
      })
    );
  }
  updated(t) {
    t.has("src") && this.throttleUpdateImage(), t.has("disabled") && (this.disabled ? (clearTimeout(this.loadedTimeout), this.image.src = "") : this.throttleUpdateImage());
  }
};
K.styles = R`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  `;
let N = K;
z([
  i({ type: String })
], N.prototype, "src");
z([
  i({ type: Number })
], N.prototype, "width");
z([
  i({ type: Number })
], N.prototype, "height");
z([
  i({ type: Array })
], N.prototype, "origin");
z([
  i({ type: Boolean })
], N.prototype, "disabled");
z([
  i({ type: Boolean, attribute: "hide-crosshair" })
], N.prototype, "hideCrosshair");
z([
  i({ type: String, attribute: "crosshair-color" })
], N.prototype, "crosshairColor");
customElements.get("frc-canvas-mjpg-stream-instance") || customElements.define(
  "frc-canvas-mjpg-stream-instance",
  N
);
var yt = Object.defineProperty, S = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && yt(t, r, e), e;
}, U;
const I = (U = class extends k {
  constructor() {
    super(...arguments), this.srcs = [], this.width = null, this.height = null, this.origin = [0, 0], this.waitImage = U.DEFAULT_WAIT_IMAGE, this.hideCrosshair = !1, this.crosshairColor = "white", this.waitImageElement = new Image();
  }
  getImageSize(s) {
    const t = {
      width: this.width || s.width,
      height: this.height || s.height
    };
    return this.waitImageElement.height / this.waitImageElement.width * t.width > t.height ? {
      height: t.height,
      width: this.waitImageElement.width / this.waitImageElement.height * t.height
    } : {
      height: this.waitImageElement.height / this.waitImageElement.width * t.width,
      width: t.width
    };
  }
  draw(s) {
    const { canvas: t, ctx: r } = s, a = [...this.streamInstances].find(
      (e) => e.src === this._connectedSrc
    );
    if (a)
      a.draw(s);
    else {
      const { width: e, height: o } = this.getImageSize(t), n = {
        width: this.width || t.width,
        height: this.height || t.height
      }, [l, h] = this.origin ?? [0, 0];
      r.translate(l, h);
      try {
        r.drawImage(
          this.waitImageElement,
          (n.width - e) / 2,
          (n.height - o) / 2,
          e,
          o
        );
      } catch {
      }
    }
  }
  updated(s) {
    s.has("srcs") && this._connectedSrc && !this.srcs.includes(this._connectedSrc) && (this._connectedSrc = void 0), s.has("waitImage") && (this.waitImageElement.src = this.waitImage);
  }
  onConnect(s) {
    this._connectedSrc || (this._connectedSrc = s);
  }
  onDisconnect(s) {
    this._connectedSrc === s && (this._connectedSrc = void 0);
  }
  renderStreamInstance(s) {
    return j`
      ${gt(
      s,
      j`
          <frc-canvas-mjpg-stream-instance
            @connect=${() => this.onConnect(s)}
            @disconnect=${() => this.onDisconnect(s)}
            src=${s}
            width=${D(this.width !== null ? this.width : void 0)}
            height=${D(this.height !== null ? this.height : void 0)}
            .origin=${D(this.origin !== null ? this.origin : void 0)}
            ?disabled=${this._connectedSrc && this._connectedSrc !== s}
            ?hide-crosshair=${this.hideCrosshair}
            crosshair-color=${this.crosshairColor}
          ></frc-canvas-mjpg-stream-instance>
        `
    )}
    `;
  }
  render() {
    return j`
      ${this.srcs.map(
      (s) => this.renderStreamInstance(s.replace("mjpg:", ""))
    )}
    `;
  }
}, U.DEFAULT_WAIT_IMAGE = "./no-camera-stream.jpg", U);
S([
  i({ type: Array })
], I.prototype, "srcs");
S([
  i({ type: Number })
], I.prototype, "width");
S([
  i({ type: Number })
], I.prototype, "height");
S([
  i({ type: Array })
], I.prototype, "origin");
S([
  i({ type: String, attribute: "wait-image" })
], I.prototype, "waitImage");
S([
  i({ type: Boolean, attribute: "hide-crosshair" })
], I.prototype, "hideCrosshair");
S([
  i({ type: String, attribute: "crosshair-color" })
], I.prototype, "crosshairColor");
S([
  J()
], I.prototype, "_connectedSrc");
S([
  at("frc-canvas-mjpg-stream-instance")
], I.prototype, "streamInstances");
let G = I;
customElements.get("frc-canvas-mjpg-stream") || customElements.define("frc-canvas-mjpg-stream", G);
var ut = Object.defineProperty, H = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && ut(t, r, e), e;
};
const Q = class extends k {
  constructor() {
    super(...arguments), this.width = null, this.backgroundColor = "black";
  }
  getCanvasCtx() {
    return this.canvas.getContext("2d");
  }
  drawChildren() {
    const t = {
      canvas: this.canvas,
      ctx: this.getCanvasCtx(),
      domRect: this.getBoundingClientRect()
    };
    [...this.children].forEach((r) => {
      var a;
      const e = this.getCanvasCtx();
      e.save(), e.beginPath();
      const o = r;
      (a = o.draw) == null || a.call(o, t), e.restore();
    });
  }
  drawBackground() {
    const t = this.getCanvasCtx();
    t.save(), t.fillStyle = this.backgroundColor, t.fillRect(0, 0, this.canvas.width, this.canvas.height), t.restore();
  }
  drawCanvas() {
    this.drawBackground(), this.drawChildren(), window.requestAnimationFrame(() => {
      this.drawCanvas();
    });
  }
  firstUpdated() {
    this.drawCanvas(), new ResizeObserver(() => this.resized()).observe(this), this.resized();
  }
  resized() {
    const t = this.getBoundingClientRect(), { width: r, height: a } = t;
    typeof this.width != "number" ? (this.canvas.width = r, this.canvas.height = a) : (this.canvas.width = this.width, this.canvas.height = this.width * a / r);
  }
  render() {
    return j` <canvas></canvas> `;
  }
};
Q.styles = R`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    [part='box'] {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-content: center;
      flex-wrap: wrap;
      background-color: var(--box-color);
      text-align: center;
    }
  `;
let B = Q;
H([
  Z("canvas")
], B.prototype, "canvas");
H([
  i({ type: Number })
], B.prototype, "width");
H([
  i({ type: String, attribute: "background-color" })
], B.prototype, "backgroundColor");
customElements.get("frc-canvas") || customElements.define("frc-canvas", B);
var ft = Object.defineProperty, L = (s, t, r, a) => {
  for (var e = void 0, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (e = n(t, r, e) || e);
  return e && ft(t, r, e), e;
};
const V = class extends k {
  constructor() {
    super(...arguments), this.streams = [], this.backgroundColor = "black", this.waitImage = G.DEFAULT_WAIT_IMAGE, this.hideCrosshair = !1, this.crosshairColor = "white";
  }
  render() {
    return j`
      <frc-canvas background-color=${this.backgroundColor}>
        <frc-canvas-mjpg-stream
          wait-image=${this.waitImage}
          crosshair-color=${this.crosshairColor}
          ?hide-crosshair=${this.hideCrosshair}
          .srcs=${this.streams}
        ></frc-canvas-mjpg-stream>
      </frc-canvas>
    `;
  }
};
V.styles = R`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    frc-canvas {
      width: 100%;
      height: 100%;
    }
  `;
let M = V;
L([
  i({ type: Array })
], M.prototype, "streams");
L([
  i({ type: String, attribute: "background-color" })
], M.prototype, "backgroundColor");
L([
  i({ type: String, attribute: "wait-image" })
], M.prototype, "waitImage");
L([
  i({ type: Boolean, attribute: "hide-crosshair" })
], M.prototype, "hideCrosshair");
L([
  i({ type: String, attribute: "crosshair-color" })
], M.prototype, "crosshairColor");
customElements.get("frc-camera-wrapper") || customElements.define("frc-camera-wrapper", M);
const Nt = O({
  tagName: "frc-canvas",
  elementClass: B,
  react: E
}), zt = O({
  tagName: "frc-canvas-circle",
  elementClass: y,
  react: E
}), Tt = O({
  tagName: "frc-canvas-group",
  elementClass: $,
  react: E
}), Mt = O({
  tagName: "frc-canvas-line",
  elementClass: C,
  react: E
}), Pt = O({
  tagName: "frc-canvas-mjpg-stream",
  elementClass: G,
  react: E
}), _t = O({
  tagName: "frc-canvas-ngon",
  elementClass: u,
  react: E
}), Wt = O({
  tagName: "frc-canvas-rect",
  elementClass: m,
  react: E
}), jt = O({
  tagName: "frc-canvas-text",
  elementClass: g,
  react: E
});
export {
  Nt as Canvas,
  zt as CanvasCircle,
  Tt as CanvasGroup,
  Mt as CanvasLine,
  Pt as CanvasMjpgStream,
  _t as CanvasNGon,
  Wt as CanvasRect,
  jt as CanvasText,
  Nt as default
};
