import x from "react";
import { U as C, M as r, H as w, O as k, o as $ } from "../property-C4BPH-wS-7fb0a59c.js";
var N = (e) => {
  throw TypeError(e);
}, I = (e, t, i) => t.has(e) || N("Cannot " + i), P = (e, t, i) => t.has(e) ? N("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, i), o = (e, t, i) => (I(e, t, "access private method"), i), j = Object.defineProperty, f = (e, t, i, E) => {
  for (var n = void 0, a = e.length - 1, l; a >= 0; a--)
    (l = e[a]) && (n = l(t, i, n) || n);
  return n && j(t, i, n), n;
}, s, h;
const F = class extends w {
  constructor() {
    super(...arguments), P(this, s), this.p = 0, this.i = 0, this.d = 0, this.setpoint = 0, this.running = !1;
  }
  onPChange(t) {
    this.p = parseFloat(t.target.value), o(this, s, h).call(this);
  }
  onIChange(t) {
    this.i = parseFloat(t.target.value), o(this, s, h).call(this);
  }
  onDChange(t) {
    this.d = parseFloat(t.target.value), o(this, s, h).call(this);
  }
  onSetpointChange(t) {
    this.setpoint = parseFloat(t.target.value), o(this, s, h).call(this);
  }
  onRunningClick() {
    this.running = !this.running, o(this, s, h).call(this);
  }
  render() {
    return k`
      <input
        type="checkbox"
        id="running"
        .checked=${this.running}
        @click=${this.onRunningClick}
      />
      <label for="running">Running</label>
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Setpoint</label>
      <input
        type="number"
        .value=${this.setpoint}
        @change=${this.onSetpointChange}
      />
    `;
  }
};
s = /* @__PURE__ */ new WeakSet(), h = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        setpoint: this.setpoint,
        running: this.running
      }
    })
  );
}, F.styles = C`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      width: 150px;
      height: auto;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input[type='number'] {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }

    input[type='checkbox'] {
      justify-self: right;
      margin: 0;
      width: 16px;
      height: 16px;
    }

    label[for='running'] {
      justify-self: left;
    }
  `;
let p = F;
f([
  r({ type: Number })
], p.prototype, "p");
f([
  r({ type: Number })
], p.prototype, "i");
f([
  r({ type: Number })
], p.prototype, "d");
f([
  r({ type: Number })
], p.prototype, "setpoint");
f([
  r({ type: Boolean, reflect: !0 })
], p.prototype, "running");
customElements.get("frc-pid-command") || customElements.define("frc-pid-command", p);
var O = Object.defineProperty, v = (e, t, i, E) => {
  for (var n = void 0, a = e.length - 1, l; a >= 0; a--)
    (l = e[a]) && (n = l(t, i, n) || n);
  return n && O(t, i, n), n;
}, c, b;
const D = class extends w {
  constructor() {
    super(...arguments), P(this, c), this.p = 0, this.i = 0, this.d = 0, this.setpoint = 0;
  }
  onPChange(t) {
    this.p = parseFloat(t.target.value), o(this, c, b).call(this);
  }
  onIChange(t) {
    this.i = parseFloat(t.target.value), o(this, c, b).call(this);
  }
  onDChange(t) {
    this.d = parseFloat(t.target.value), o(this, c, b).call(this);
  }
  onSetpointChange(t) {
    this.setpoint = parseFloat(t.target.value), o(this, c, b).call(this);
  }
  render() {
    return k`
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Setpoint</label>
      <input
        type="number"
        .value=${this.setpoint}
        @change=${this.onSetpointChange}
      />
    `;
  }
};
c = /* @__PURE__ */ new WeakSet(), b = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        setpoint: this.setpoint
      }
    })
  );
}, D.styles = C`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      height: auto;
      width: 150px;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }
  `;
let g = D;
v([
  r({ type: Number })
], g.prototype, "p");
v([
  r({ type: Number })
], g.prototype, "i");
v([
  r({ type: Number })
], g.prototype, "d");
v([
  r({ type: Number })
], g.prototype, "setpoint");
customElements.get("frc-pid-controller") || customElements.define("frc-pid-controller", g);
var R = Object.defineProperty, y = (e, t, i, E) => {
  for (var n = void 0, a = e.length - 1, l; a >= 0; a--)
    (l = e[a]) && (n = l(t, i, n) || n);
  return n && R(t, i, n), n;
}, u, m;
const S = class extends w {
  constructor() {
    super(...arguments), P(this, u), this.p = 0, this.i = 0, this.d = 0, this.goal = 0;
  }
  onPChange(t) {
    this.p = parseFloat(t.target.value), o(this, u, m).call(this);
  }
  onIChange(t) {
    this.i = parseFloat(t.target.value), o(this, u, m).call(this);
  }
  onDChange(t) {
    this.d = parseFloat(t.target.value), o(this, u, m).call(this);
  }
  onGoalChange(t) {
    this.goal = parseFloat(t.target.value), o(this, u, m).call(this);
  }
  render() {
    return k`
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Goal</label>
      <input type="number" .value=${this.goal} @change=${this.onGoalChange} />
    `;
  }
};
u = /* @__PURE__ */ new WeakSet(), m = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        goal: this.goal
      }
    })
  );
}, S.styles = C`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      height: auto;
      width: 150px;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }
  `;
let d = S;
y([
  r({ type: Number })
], d.prototype, "p");
y([
  r({ type: Number })
], d.prototype, "i");
y([
  r({ type: Number })
], d.prototype, "d");
y([
  r({ type: Number })
], d.prototype, "goal");
customElements.get("frc-profiled-pid-controller") || customElements.define("frc-profiled-pid-controller", d);
const B = $({
  tagName: "frc-pid-command",
  elementClass: p,
  react: x,
  events: {
    onchange: "change"
  }
}), H = $({
  tagName: "frc-pid-controller",
  elementClass: g,
  react: x,
  events: {
    onchange: "change"
  }
}), T = $({
  tagName: "frc-profiled-pid-controller",
  elementClass: d,
  react: x,
  events: {
    onchange: "change"
  }
});
export {
  B as PidCommand,
  H as PidController,
  T as ProfiledPidController
};
