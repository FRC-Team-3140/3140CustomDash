import $ from "react";
import { U as A, M as h, H as M, O as k, o as B } from "../property-C4BPH-wS-7fb0a59c.js";
import { h as W } from "../query-BrpQj_Qi-db00b239.js";
import { s as G, c as u } from "../units-DyibxdHs-d7e14be8.js";
import { n as E } from "../state-Cn3aen3G-6b8e5a08.js";
import { i as I, o as tt } from "../index-BXxACewW-cecd5a05.js";
import "../_commonjsHelpers-DaMA6jEr-bedfce41.js";
var D = (n) => {
  throw TypeError(n);
}, _ = (n, t, e) => t.has(n) || D("Cannot " + e), b = (n, t, e) => (_(n, t, "read from private field"), e ? e.call(n) : t.get(n)), L = (n, t, e) => t.has(n) ? D("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e), H = (n, t, e, i) => (_(n, t, "write to private field"), i ? i.call(n, e) : t.set(n, e), e), et = (n, t, e) => (_(n, t, "access private method"), e);
const O = [
  // https://www.chiefdelphi.com/t/4k-field-image-2025-reefscape/478797
  {
    game: "Reefscape",
    image: "./field-images/2025-field.jpg",
    corners: {
      topLeft: [421, 91],
      bottomRight: [3352, 1437]
    },
    size: [57.57291667, 26.4167],
    unit: "foot"
  },
  // Thanks to MikLast for providing the 2024 field image here:
  // https://www.chiefdelphi.com/t/2024-crescendo-top-down-field-renders/447764
  {
    game: "Crescendo",
    image: "./field-images/2024-field.jpg",
    corners: {
      topLeft: [513, 78],
      bottomRight: [3327, 1475]
    },
    size: [54.265092, 26.31234],
    unit: "foot"
  },
  {
    game: "Charged Up",
    image: "./field-images/2023-field.jpg",
    corners: {
      topLeft: [46, 36],
      bottomRight: [1088, 544]
    },
    size: [54.27083, 26.2916],
    unit: "foot"
  },
  {
    game: "Rapid React",
    image: "./field-images/2022-field.jpg",
    corners: {
      topLeft: [74, 50],
      bottomRight: [1774, 900]
    },
    size: [54, 27],
    unit: "foot"
  },
  {
    game: "Infinite Recharge",
    image: "./field-images/2020-field.jpg",
    corners: {
      topLeft: [96, 25],
      bottomRight: [1040, 514]
    },
    size: [52.4375, 26.9375],
    unit: "foot"
  },
  {
    game: "Destination: Deep Space",
    image: "./field-images/2019-field.jpg",
    corners: {
      topLeft: [217, 40],
      bottomRight: [1372, 615]
    },
    size: [54, 27],
    unit: "foot"
  },
  {
    game: "FIRST Power Up",
    image: "./field-images/2018-field.jpg",
    corners: {
      topLeft: [125, 20],
      bottomRight: [827, 370]
    },
    size: [54, 27],
    unit: "feet"
  },
  {
    game: "Barrel Racing Path",
    image: "./field-images/2021-barrel.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Bounce Path",
    image: "./field-images/2021-bounce.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Galactic Search A",
    image: "./field-images/2021-galacticsearcha.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Galactic Search B",
    image: "./field-images/2021-galacticsearchb.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Slalom Path",
    image: "./field-images/2021-slalom.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  }
];
var S, F;
class N {
  constructor() {
    L(this, S, {}), L(this, F, /* @__PURE__ */ new Map());
  }
  getImage(t) {
    if (typeof b(this, S)[t] > "u") {
      const e = new Image(), i = {
        src: t,
        width: 0,
        height: 0,
        loaded: !1,
        image: e
      };
      e.onload = () => {
        i.loaded = !0, i.width = e.width, i.height = e.height, [...b(this, F).values()].forEach((o) => {
          o(t);
        });
      }, b(this, S)[t] = i, e.src = t;
    }
    return b(this, S)[t];
  }
  static getBoundingBoxDims(t, e) {
    const i = Math.abs(t.width * Math.cos(e)) + Math.abs(t.height * Math.sin(e)), o = Math.abs(t.width * Math.sin(e)) + Math.abs(t.height * Math.cos(e));
    return {
      width: i,
      height: o
    };
  }
  static fitImageInsideBox(t, e) {
    return e.width / t.width * t.height <= e.height ? {
      width: e.width,
      height: e.width / t.width * t.height
    } : {
      width: e.height / t.height * t.width,
      height: e.height
    };
  }
  onImageLoad(t) {
    const e = Symbol("image");
    return b(this, F).set(e, t), () => {
      b(this, F).delete(e);
    };
  }
}
S = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap();
var it = Object.defineProperty, P = (n, t, e, i) => {
  for (var o = void 0, s = n.length - 1, r; s >= 0; s--)
    (r = n[s]) && (o = r(t, e, o) || o);
  return o && it(t, e, o), o;
};
class w extends M {
  constructor() {
    super(...arguments), this.unit = "inherit", this.rotationUnit = "inherit", this.image = "", this.color = "#0000ff", this.opacity = 1, this.pose = [0, 0, 0], this.width = 0.6, this.length = 0.9;
  }
  draw({
    canvas: t,
    unit: e,
    rotationUnit: i,
    xToPx: o,
    yToPx: s,
    lengthToPx: r,
    origin: a
  }) {
    const p = this.unit === "inherit" || this.unit === null ? e : this.unit, y = this.rotationUnit === "inherit" || this.rotationUnit === null ? i : this.rotationUnit, [c, m] = this.pose, C = y === "rad" ? this.pose[2] : this.pose[2] / (180 / Math.PI);
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), t.fillStyle = "#222", t.strokeStyle = this.color, t.lineWidth = r(3, "in"), t.translate(o(c, p), s(m, p)), t.rotate(-C + (a === "red" ? Math.PI : 0)), t.roundRect(
      -r(this.length / 2, p),
      -r(this.width / 2, p),
      r(this.length, p),
      r(this.width, p),
      1
    ), t.fill(), t.stroke(), t.beginPath(), t.fillStyle = "white", t.strokeStyle = "white", t.lineWidth = r(2, "in"), t.moveTo(-r(this.length * 0.3, p), 0), t.lineTo(r(this.length * 0.3, p), 0), t.moveTo(
      r(this.length * 0.1, p),
      -r(this.width * 0.25, p)
    ), t.lineTo(r(this.length * 0.3, p), 0), t.lineTo(
      r(this.length * 0.1, p),
      r(this.width * 0.25, p)
    ), t.stroke();
  }
}
P([
  h({ type: String })
], w.prototype, "unit");
P([
  h({ type: String, attribute: "rotation-unit" })
], w.prototype, "rotationUnit");
P([
  h({ type: String })
], w.prototype, "image");
P([
  h({ type: String })
], w.prototype, "color");
P([
  h({ type: Number })
], w.prototype, "opacity");
P([
  h({ type: Array })
], w.prototype, "pose");
P([
  h({ type: Number })
], w.prototype, "width");
P([
  h({ type: Number })
], w.prototype, "length");
customElements.get("frc-field-robot") || customElements.define("frc-field-robot", w);
var ot = Object.defineProperty, T = (n, t, e, i) => {
  for (var o = void 0, s = n.length - 1, r; s >= 0; s--)
    (r = n[s]) && (o = r(t, e, o) || o);
  return o && ot(t, e, o), o;
};
class x extends M {
  constructor() {
    super(...arguments), this.poses = [], this.translations = [], this.color = "#FFA500", this.unit = "inherit", this.lineWidth = 4, this.opacity = 0.7, this._poses = [], this._translations = [];
  }
  updated(t) {
    var e;
    t.has("poses") && (typeof ((e = this.poses) == null ? void 0 : e[0]) == "number" || this.poses instanceof Uint8Array ? this._poses = I(this.poses) : this._poses = this.poses), t.has("translations") && (this._translations = I(this.translations, 2));
  }
  draw({ canvas: t, unit: e, xToPx: i, yToPx: o }) {
    const s = this.unit === "inherit" || this.unit === null ? e : this.unit;
    if (t.lineWidth = this.lineWidth, t.strokeStyle = this.color, t.globalAlpha = this.opacity, this._poses.length > 1) {
      for (let r = 0; r < this._poses.length - 1; r += 1) {
        const [a, p] = this._poses[r], [y, c] = this._poses[r + 1];
        t.moveTo(i(a, s), o(p, s)), t.lineTo(i(y, s), o(c, s));
      }
      t.stroke();
    }
    if (this._translations.length > 1) {
      for (let r = 0; r < this._translations.length - 1; r += 1) {
        const [a, p] = this._translations[r], [y, c] = this._translations[r + 1];
        t.moveTo(i(a, s), o(p, s)), t.lineTo(i(y, s), o(c, s));
      }
      t.stroke();
    }
  }
}
T([
  h({ type: Array })
], x.prototype, "poses");
T([
  h({ type: Array })
], x.prototype, "translations");
T([
  h({ type: String })
], x.prototype, "color");
T([
  h({ type: String })
], x.prototype, "unit");
T([
  h({ type: Number, attribute: "line-width" })
], x.prototype, "lineWidth");
T([
  h({ type: Number })
], x.prototype, "opacity");
T([
  E()
], x.prototype, "_poses");
T([
  E()
], x.prototype, "_translations");
customElements.get("frc-field-path") || customElements.define("frc-field-path", x);
var st = Object.defineProperty, f = (n, t, e, i) => {
  for (var o = void 0, s = n.length - 1, r; s >= 0; s--)
    (r = n[s]) && (o = r(t, e, o) || o);
  return o && st(t, e, o), o;
};
function rt(n) {
  return n * Math.PI / 180;
}
var v, U, X;
const V = class extends M {
  constructor() {
    super(...arguments), L(this, U), L(this, v), this.game = O[0].game, this.cropTop = null, this.cropBottom = null, this.cropLeft = null, this.cropRight = null, this.cropType = "percent", this.unit = G, this.rotationUnit = "rad", this.rotation = 0, this.showGrid = !1, this.gridSize = 1, this.origin = "blue", H(this, v, new N());
  }
  getConfig() {
    return O.find(({ game: t }) => t === this.game) ?? O[0];
  }
  getCanvasCtx() {
    return this.canvas.getContext("2d");
  }
  getCropPercent() {
    if (this.cropType === "percent") {
      const q = this.cropLeft ?? 0, J = this.cropTop ?? 0, Q = this.cropRight ?? 1, Z = this.cropBottom ?? 1;
      return { x1: q, y1: J, x2: Q, y2: Z };
    }
    const { corners: t, image: e, unit: i, size: o } = this.getConfig(), { loaded: s, width: r, height: a } = b(this, v).getImage(e);
    if (!s)
      return { x1: 0, y1: 0, x2: 1, y2: 1 };
    const p = [this.cropLeft ?? 0, this.cropTop ?? 0], y = [
      this.cropRight ?? u(o[0], i, this.unit),
      this.cropBottom ?? u(o[1], i, this.unit)
    ], c = t.topLeft[0] / r, m = t.topLeft[1] / a, C = t.bottomRight[0] / r, j = t.bottomRight[1] / a, R = C - c, K = j - m;
    return {
      x1: c + R * u(p[0], this.unit, i) / o[0],
      y1: m + K * u(p[1], this.unit, i) / o[1],
      x2: c + R * u(y[0], this.unit, i) / o[0],
      y2: m + K * u(y[1], this.unit, i) / o[1]
    };
  }
  getFieldRectPx() {
    const { corners: t, image: e } = this.getConfig(), { loaded: i, width: o, height: s } = b(this, v).getImage(e);
    if (!i)
      return { x: 0, y: 0, width: 0, height: 0 };
    const r = t.topLeft[0] / o, a = t.topLeft[1] / s, p = t.bottomRight[0] / o, y = t.bottomRight[1] / s, c = this.getCropPercent(), m = c.x2 - c.x1, C = c.y2 - c.y1, j = this.canvas.width / m, R = this.canvas.height / C;
    return {
      x: (r - c.x1) * j,
      y: (a - c.y1) * R,
      width: (p - r) * j,
      height: (y - a) * R
    };
  }
  pxToX(t, e = this.unit) {
    const i = this.getFieldRectPx(), { size: o, unit: s } = this.getConfig();
    if (i.width === 0)
      return 0;
    const r = i.width / o[0], a = t * (this.canvas.width / this.canvas.clientWidth), p = this.origin !== "red" ? (a - i.x) / r : (i.x + i.width - a) / r;
    return u(p, s, e);
  }
  xToPx(t, e = this.unit) {
    const i = this.getFieldRectPx(), { size: o, unit: s } = this.getConfig();
    if (i.width === 0)
      return 0;
    const r = i.width / o[0], a = u(t, e, s);
    return this.origin !== "red" ? i.x + a * r : i.x + i.width - a * r;
  }
  yToPx(t, e = this.unit) {
    const i = this.getFieldRectPx(), { size: o, unit: s } = this.getConfig();
    if (i.height === 0)
      return 0;
    const r = i.height / o[1], a = u(t, e, s);
    return this.origin !== "red" ? i.y + i.height - a * r : i.y + a * r;
  }
  pxToY(t, e = this.unit) {
    const i = this.getFieldRectPx(), { size: o, unit: s } = this.getConfig();
    if (i.height === 0)
      return 0;
    const r = i.height / o[1], a = t * (this.canvas.height / this.canvas.clientHeight), p = this.origin !== "red" ? (i.y + i.height - a) / r : (a - i.y) / r;
    return u(p, s, e);
  }
  lengthToPx(t, e = this.unit) {
    const i = this.getFieldRectPx(), { size: o, unit: s } = this.getConfig();
    if (i.width === 0)
      return 0;
    const r = i.width / o[0];
    return u(t, e, s) * r;
  }
  setContainerSize() {
    const t = { width: this.clientWidth, height: this.clientHeight }, e = this.getConfig().image, i = b(this, v).getImage(e), { loaded: o } = i;
    if (!o)
      return;
    const s = this.getCropPercent(), r = {
      width: (s.x2 - s.x1) * i.width,
      height: (s.y2 - s.y1) * i.height
    }, a = N.getBoundingBoxDims(
      r,
      rt(this.rotation)
    ), p = N.fitImageInsideBox(a, {
      width: t.width,
      height: t.height
    }).width / a.width;
    this.container.style.width = `${r.width * p}px`, this.container.style.height = `${r.height * p}px`;
  }
  drawImage() {
    const t = this.getCanvasCtx(), e = this.getConfig().image, { loaded: i, image: o, width: s, height: r } = b(this, v).getImage(e);
    if (!i)
      return;
    const { clientWidth: a, clientHeight: p } = this.canvas, y = a * window.devicePixelRatio, c = p * window.devicePixelRatio;
    this.canvas.width = y, this.canvas.height = c;
    const m = this.getCropPercent();
    t.drawImage(
      o,
      m.x1 * s,
      m.y1 * r,
      (m.x2 - m.x1) * s,
      (m.y2 - m.y1) * r,
      0,
      0,
      y,
      c
    );
  }
  drawFieldRect() {
    const t = this.getCanvasCtx(), { x: e, y: i, width: o, height: s } = this.getFieldRectPx();
    t.rect(e, i, o, s), t.lineWidth = 2, t.strokeStyle = "yellow", t.stroke();
  }
  drawGrid() {
    const t = this.getCanvasCtx(), { image: e, size: i } = this.getConfig(), { loaded: o } = b(this, v).getImage(e);
    if (!(!o || !this.showGrid || this.gridSize <= 0)) {
      t.lineWidth = 1, t.strokeStyle = "gray";
      for (let s = 0; s <= i[0]; s += this.gridSize)
        t.beginPath(), t.moveTo(this.xToPx(s), this.yToPx(0)), t.lineTo(this.xToPx(s), this.yToPx(i[1])), t.stroke();
      for (let s = 0; s <= i[1]; s += this.gridSize)
        t.beginPath(), t.moveTo(this.xToPx(0), this.yToPx(s)), t.lineTo(this.xToPx(i[0]), this.yToPx(s)), t.stroke();
    }
  }
  drawChildren() {
    const t = {
      canvas: this.getCanvasCtx(),
      getFieldRectPx: () => this.getFieldRectPx(),
      unit: this.unit,
      rotationUnit: this.rotationUnit,
      xToPx: (e, i) => this.xToPx(e, i),
      yToPx: (e, i) => this.yToPx(e, i),
      lengthToPx: (e, i) => this.lengthToPx(e, i),
      origin: this.origin
    };
    [...this.children].flatMap((e) => e.tagName === "SLOT" ? e.assignedElements() : e).forEach((e) => {
      var i;
      const o = this.getCanvasCtx();
      o.save(), o.beginPath();
      const s = e;
      (i = s.draw) == null || i.call(s, t), o.restore();
    });
  }
  drawField() {
    this.setContainerSize(), this.drawImage(), this.drawFieldRect(), this.drawGrid(), this.drawChildren(), window.requestAnimationFrame(() => {
      this.drawField();
    });
  }
  firstUpdated() {
    this.drawField();
  }
  render() {
    return k`
      <div class="outside-container">
        <div class="container" style="transform: rotate(${-this.rotation}deg)">
          <canvas @click=${et(this, U, X)}></canvas>
        </div>
      </div>
    `;
  }
};
v = /* @__PURE__ */ new WeakMap(), U = /* @__PURE__ */ new WeakSet(), X = function(n) {
  const t = this.pxToX(n.offsetX), e = this.pxToY(n.offsetY);
  this.dispatchEvent(
    new CustomEvent("fieldClick", {
      detail: {
        feet: {
          x: u(t, this.unit, "ft"),
          y: u(e, this.unit, "ft")
        },
        meters: {
          x: u(t, this.unit, "m"),
          y: u(e, this.unit, "m")
        }
      },
      bubbles: !0,
      composed: !0
    })
  );
}, V.styles = A`
    :host {
      display: inline-flex;
      position: relative;
      width: 500px;
      height: 300px;
      justify-content: center;
      align-items: center;
    }

    .container {
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  `;
let l = V;
f([
  h({ type: String })
], l.prototype, "game");
f([
  h({ type: Number, attribute: "crop-top" })
], l.prototype, "cropTop");
f([
  h({ type: Number, attribute: "crop-bottom" })
], l.prototype, "cropBottom");
f([
  h({ type: Number, attribute: "crop-left" })
], l.prototype, "cropLeft");
f([
  h({ type: Number, attribute: "crop-right" })
], l.prototype, "cropRight");
f([
  h({ type: String, attribute: "crop-type" })
], l.prototype, "cropType");
f([
  h({ type: String })
], l.prototype, "unit");
f([
  h({ type: String, attribute: "rotation-unit" })
], l.prototype, "rotationUnit");
f([
  h({ type: Number })
], l.prototype, "rotation");
f([
  h({ type: Boolean, attribute: "show-grid" })
], l.prototype, "showGrid");
f([
  h({ type: Number, attribute: "grid-size" })
], l.prototype, "gridSize");
f([
  h({ type: String })
], l.prototype, "origin");
f([
  W("canvas", !0)
], l.prototype, "canvas");
f([
  W(".container", !0)
], l.prototype, "container");
customElements.get("frc-field") || customElements.define("frc-field", l);
class ht {
  constructor(t, e) {
    this.sourceKey = "", this.sourceProvider = "", this.store = t, this.onUpdate = e;
  }
  setSource(t, e) {
    var i;
    this.sourceKey = t, this.sourceProvider = e, this.addFieldObjectsFromSources(), (i = this.unsubscriber) == null || i.call(this);
    const o = tt(() => {
      this.addFieldObjectsFromSources();
    }, 1e3 / 60);
    this.unsubscriber = this.store.subscribe(e, t, o, !0);
  }
  addFieldObjectsFromSources() {
    var t;
    const e = this.store.getSource(this.sourceProvider, this.sourceKey);
    if (!e || ((t = e.getChildren()[".type"]) == null ? void 0 : t.getValue()) !== "Field2d")
      return;
    const i = [];
    Object.entries(e.getChildren()).forEach(([o, s]) => {
      if (o.startsWith(".") || o === "XModules")
        return;
      const r = s.hasChildren() ? s.getChildren().pose.getValue() : s.getValue(), a = I(r);
      i.push({
        type: a.length === 1 ? "robot" : "trajectory",
        poses: a,
        sourceKey: s.getKey(),
        sourceProvider: this.sourceProvider
      }), this.onUpdate(i);
    });
  }
}
var nt = Object.defineProperty, d = (n, t, e, i) => {
  for (var o = void 0, s = n.length - 1, r; s >= 0; s--)
    (r = n[s]) && (o = r(t, e, o) || o);
  return o && nt(t, e, o), o;
}, z;
const Y = class extends M {
  constructor() {
    super(...arguments), L(this, z), this.sourceProvider = "", this.sourceKey = "", this.game = O[0].game, this.cropTop = 0, this.cropBottom = 100, this.cropLeft = 0, this.cropRight = 100, this.cropType = "percent", this.unit = G, this.rotationUnit = "deg", this.rotation = 0, this.showGrid = !1, this.gridSize = 1, this.origin = "blue", this.fieldObjects = [];
  }
  firstUpdated() {
    this.store && (this.fieldObjectManager = new ht(
      this.store,
      (t) => {
        this.fieldObjects = t;
      }
    )), H(this, z, new MutationObserver(() => {
      this.requestUpdate();
    })), b(this, z).observe(this, {
      attributes: !0,
      childList: !0,
      subtree: !0,
      attributeFilter: ["source-key", "source-provider"]
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), b(this, z).disconnect();
  }
  updated(t) {
    (t.has("sourceKey") || t.has("sourceProvider")) && this.fieldObjectManager.setSource(this.sourceKey, this.sourceProvider);
  }
  render() {
    var t;
    const e = (((t = this.slottedFieldObjects) == null ? void 0 : t.assignedElements()) ?? []).filter((i) => i.tagName === "FRC-FIELD-ROBOT" || i.tagName === "FRC-FIELD-PATH").map((i) => ({
      type: i.tagName === "FRC-FIELD-ROBOT" ? "robot" : "trajectory",
      sourceKey: i.getAttribute("source-key"),
      sourceProvider: i.getAttribute("source-provider")
    }));
    return k`
      <frc-field
        game=${this.game}
        unit=${this.unit}
        rotation-unit=${this.rotationUnit}
        rotation=${this.rotation}
        ?show-grid=${this.showGrid}
        grid-size=${this.gridSize}
        origin=${this.origin}
        crop-top=${this.cropTop / 100}
        crop-bottom=${this.cropBottom / 100}
        crop-left=${this.cropLeft / 100}
        crop-right=${this.cropRight / 100}
        crop-type=${this.cropType}
      >
        ${this.fieldObjects.filter((i) => !e.find(
      ({ sourceKey: o, sourceProvider: s, type: r }) => i.type === r && i.sourceKey === o && i.sourceProvider === s
    )).map((i) => i.type === "robot" ? k`<frc-field-robot
                .pose=${i.poses[0]}
              ></frc-field-robot>` : k`<frc-field-path
              .poses=${i.poses}
            ></frc-field-path>`)}
        <slot></slot>
      </frc-field>
    `;
  }
};
z = /* @__PURE__ */ new WeakMap(), Y.styles = A`
    :host {
      display: inline-block;
      position: relative;
      width: 500px;
      height: 300px;
    }

    frc-field {
      width: 100%;
      height: 100%;
    }
  `;
let g = Y;
d([
  h({ type: Object, attribute: !1 })
], g.prototype, "provider");
d([
  h({ type: Object, attribute: !1 })
], g.prototype, "store");
d([
  h({ type: String, attribute: "source-provider" })
], g.prototype, "sourceProvider");
d([
  h({ type: String, attribute: "source-key" })
], g.prototype, "sourceKey");
d([
  h({ type: String })
], g.prototype, "game");
d([
  h({ type: Number, attribute: "crop-top" })
], g.prototype, "cropTop");
d([
  h({ type: Number, attribute: "crop-bottom" })
], g.prototype, "cropBottom");
d([
  h({ type: Number, attribute: "crop-left" })
], g.prototype, "cropLeft");
d([
  h({ type: Number, attribute: "crop-right" })
], g.prototype, "cropRight");
d([
  h({ type: String, attribute: "crop-type" })
], g.prototype, "cropType");
d([
  h({ type: String })
], g.prototype, "unit");
d([
  h({ type: String, attribute: "rotation-unit" })
], g.prototype, "rotationUnit");
d([
  h({ type: Number })
], g.prototype, "rotation");
d([
  h({ type: Boolean, attribute: "show-grid" })
], g.prototype, "showGrid");
d([
  h({ type: Number, attribute: "grid-size" })
], g.prototype, "gridSize");
d([
  h({ type: String })
], g.prototype, "origin");
d([
  E()
], g.prototype, "fieldObjects");
d([
  W("slot", !0)
], g.prototype, "slottedFieldObjects");
customElements.get("frc-field-wrapper") || customElements.define("frc-field-wrapper", g);
const yt = B({
  tagName: "frc-field",
  elementClass: l,
  react: $
}), bt = B({
  tagName: "frc-field-robot",
  elementClass: w,
  react: $
}), wt = B({
  tagName: "frc-field-path",
  elementClass: x,
  react: $
});
export {
  yt as Field,
  wt as FieldPath,
  bt as FieldRobot,
  yt as default
};
