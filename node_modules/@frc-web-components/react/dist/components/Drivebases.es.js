import N from "react";
import { U as H, M as u, H as T, O, T as b, o as E } from "../property-C4BPH-wS-7fb0a59c.js";
import "../bar.es-bc02d3c5.js";
import "../axis.es-29b40501.js";
import { h as V } from "../query-BrpQj_Qi-db00b239.js";
import { E as L } from "../transform-DR-Bw75L-3629b551.js";
import "../state-Cn3aen3G-6b8e5a08.js";
function I(o) {
  return o * 180 / Math.PI;
}
function et(o, t, e, i) {
  return `<line x1="${o}" y1="${t}" x2="${e}" y2="${i}" />`;
}
function _(o, t, e) {
  return `<polygon 
            points="${o.x},${o.y} ${t.x},${t.y} ${e.x},${e.y}" />`;
}
function j(o, t, e, i) {
  const r = i * Math.PI / 180;
  return {
    x: o + e * Math.cos(r),
    y: t - e * Math.sin(r)
  };
}
function rt(o, t, e, i, r) {
  const s = j(o, t, e, r), n = j(o, t, e, i), d = r - i <= 180 ? "0" : "1", a = r > i ? 1 : 0;
  return [
    "M",
    s.x,
    s.y,
    "A",
    e,
    e,
    0,
    d,
    a,
    n.x,
    n.y
  ].join(" ");
}
function it(o, t, e, i, r) {
  return `<path d="${rt(o, t, e, i, r)}"/>`;
}
function ot(o, t, e, i) {
  const r = t / 2, s = Math.cos(o), n = Math.sin(o), d = Math.cos(o + Math.PI / 2) * r, a = Math.sin(o + Math.PI / 2) * r, c = {
    x: s * i - d + e,
    y: n * i - a
  }, h = {
    x: s * i + d + e,
    y: n * i + a
  }, l = {
    x: s * (t + i) + e,
    y: n * (t + i)
  };
  return _(c, h, l);
}
function D(o, t, e, i) {
  const r = Math.cos(t) * o, s = Math.sin(t) * o, n = et(e, 0, r + e, s), d = ot(t, i, e, o);
  return n + d;
}
function st(o, t, e, i) {
  const r = e / t, s = I(r);
  return it(
    i,
    0,
    t,
    I(o),
    I(o) - s
  );
}
function nt(o, t, e, i, r) {
  const s = t / 2, n = r / e - o, d = Math.sqrt(t * t + e * e), a = (r + t * Math.sign(r)) / e - o, c = Math.cos(n), h = Math.sin(n), l = {
    x: (e + s) * c + i,
    y: (e + s) * h
  }, y = {
    x: (e - s) * c + i,
    y: (e - s) * h
  }, v = {
    x: d * Math.cos(a) + i,
    y: d * Math.sin(a)
  };
  return _(l, v, y);
}
function G(o, t, e, i, r) {
  if (t < 0)
    throw new Error(`Radius cannot be negative. Given: ${t}`);
  return t === 1 / 0 ? D(e, o, i, r) : st(o, t, e, i) + nt(o, r, t, i, e);
}
function F(o, t, e, i, r) {
  return G(o, t, t * e, i, r);
}
var at = Object.defineProperty, W = (o, t, e, i) => {
  for (var r = void 0, s = o.length - 1, n; s >= 0; s--)
    (n = o[s]) && (r = n(t, e, r) || r);
  return r && at(t, e, r), r;
};
function P(o, t, e) {
  return Math.min(e, Math.max(o, t));
}
function dt(o, t, e, i, r) {
  return (o - t) * (r - i) / (e - t) + i;
}
function ct(o) {
  const t = o / 2, e = `
    <line 
      x1="${-t}"
      y1="${-t}"
      x2="${t}"
      y2="${t}"
    />
  `, i = `
    <line 
      x1="${-t}"
      y1="${t}"
      x2="${t}"
      y2="${-t}"
    />
  `;
  return `<g class="x">${e} ${i}</g>`;
}
const J = class extends T {
  constructor() {
    super(), this.leftMotorSpeed = 0, this.rightMotorSpeed = 0, new ResizeObserver(() => {
      this.resized();
    }).observe(this);
  }
  get clampedLeftMotorSpeed() {
    return P(this.leftMotorSpeed, -1, 1);
  }
  get clampedRightMotorSpeed() {
    return P(this.rightMotorSpeed, -1, 1);
  }
  drawMotionVector(t, e) {
    const i = this.renderRoot.querySelector("#svg").getBoundingClientRect(), r = i.width * 0.13, s = 20, n = 20, d = i.width - (r + s) * 2, a = i.height - n * 2;
    if (Math.abs(t) <= 0.05 && Math.abs(e) <= 0.05)
      return ct(i.width * 0.2);
    const c = Math.min(d, a) / 2 - 8, h = 8;
    if (Math.abs(t - e) <= 1e-3)
      return `<g class="arrow">${D(
        Math.abs(t * c),
        -Math.sign(t) * Math.PI / 2,
        0,
        h
      )}</g>`;
    const l = Math.PI, y = (e - t) / 2, v = (t + e) / 2, g = v / y;
    let S;
    if (Math.abs(g) >= 1) {
      const x = -Math.sign(g), m = (x + 1) * l / 2, $ = Math.abs(g * c);
      S = G(
        m,
        $,
        x * v * c,
        x * $,
        h
      );
    } else {
      const x = Math.sign(t - e);
      if (g === 0) {
        const m = Math.max(t, e) * c, $ = x * l, k = y < 0 ? l : 0;
        S = F(k, m, $, 0, h);
      } else {
        const m = g < 0 ? t : e, $ = g < 0 ? e : t, k = Math.abs(m) * c, Y = -g * k, Z = dt($ / m, 0, -1, 0.5, l), tt = g < 0 ? l : 0;
        S = F(
          tt,
          k,
          x * Z,
          Y,
          h
        );
      }
    }
    return `<g class="arrow">${S}</g>`;
  }
  drawDrivetrain() {
    const t = this.renderRoot.querySelector("#svg").getBoundingClientRect(), e = t.width * 0.13, i = Math.min(t.width * 0.13, t.height * 0.15), r = 20, s = 20, n = `
      <rect 
        width="calc(100% - ${(e + r) * 2}px)" 
        height="calc(100% - ${s * 2}px)"
        x="${e + r}" 
        y="20px" 
      />
    `, d = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="${r}px" 
        y="${s}px" 
      />
    `, a = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="calc(100% - ${e + r}px)" 
        y="${s}px" 
      />
    `, c = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="${r}px"
        y="calc(100% - ${i * 2 + s}px)"
      />
    `, h = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="calc(100% - ${e + r}px)" 
        y="calc(100% - ${i * 2 + s}px)"
      />
    `;
    return n + d + a + c + h;
  }
  getLeftForegroundStyle() {
    return this.getForegroundStyle(this.clampedLeftMotorSpeed);
  }
  getRightForegroundStyle() {
    return this.getForegroundStyle(this.clampedRightMotorSpeed);
  }
  getForegroundStyle(t) {
    const e = P(t, -1, 1);
    return e > 0 ? `
        height: ${Math.abs(e) / 2 * 100}%;
        top: auto;
        bottom: 50%;
      ` : `
        height: ${Math.abs(e) / 2 * 100}%;
        top: 50%;
        bottom: auto;
      `;
  }
  firstUpdated() {
    const t = this.drawMotionVector(0, 0);
    this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain(), this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  resized() {
    const t = this.drawMotionVector(
      this.clampedLeftMotorSpeed,
      this.clampedRightMotorSpeed
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
    const e = this.renderRoot.querySelector("#svg").getBoundingClientRect();
    this.renderRoot.querySelector("#forceVector").style.transform = `translate(${e.width * 0.5}px, ${e.height * 0.5}px)`, this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain();
  }
  updated() {
    const t = this.drawMotionVector(
      this.clampedLeftMotorSpeed,
      this.clampedRightMotorSpeed
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  render() {
    return O`
      <div class="diff-drive-container">
        <div class="speed">
          <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
          <div class="bar">
            <div
              class="foreground"
              style="${this.getLeftForegroundStyle()}"
            ></div>
          </div>
        </div>
        <svg id="svg">
          <g id="forceVector"></g>
          <g id="drivetrain" class="drivetrain"></g>
        </svg>
        <div class="speed">
          <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
          <div class="bar">
            <div
              class="foreground"
              style="${this.getRightForegroundStyle()}"
            ></div>
          </div>
        </div>
      </div>
    `;
  }
};
J.styles = H`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
      padding: 0 10px;
      font-family: sans-serif;
    }

    .diff-drive-container {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
    }

    svg {
      overflow: overlay;
      flex: 1;
      height: 100%;
    }

    svg .x {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
    }

    svg .arrow line,
    svg .arrow path {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
      fill: none;
    }

    svg .arrow polygon {
      stroke: rgb(50, 50, 255);
      fill: rgb(50, 50, 255);
    }

    svg .drivetrain {
      fill: none;
      stroke: var(--frc-differential-drivebase-drivetrain-color, #000);
    }

    .bar {
      position: relative;
      height: calc(100% - 30px);
      width: 20px;
      border-radius: 3px;
      margin: 15px 0;
      background: var(--frc-bar-background, #ddd);
    }

    .speed {
      display: flex;
      height: 100%;
      flex-direction: row;
      align-items: center;
      margin-left: 30px;
    }

    frc-axis {
      width: 10px;
      height: calc(100% - 35px);
    }

    .foreground {
      position: absolute;
      top: 0;
      width: 20px;
      background: var(--frc-bar-foreground, lightblue);
      border-radius: 3px;
    }
  `;
let B = J;
W([
  u({ type: Number, attribute: "left-motor-speed" })
], B.prototype, "leftMotorSpeed");
W([
  u({ type: Number, attribute: "right-motor-speed" })
], B.prototype, "rightMotorSpeed");
customElements.get("frc-differential-drivebase") || customElements.define("frc-differential-drivebase", B);
var ht = Object.defineProperty, q = (o, t, e, i) => {
  for (var r = void 0, s = o.length - 1, n; s >= 0; s--)
    (n = o[s]) && (r = n(t, e, r) || r);
  return r && ht(t, e, r), r;
};
function lt(o) {
  const t = o / 2, e = `
    <line 
      x1="${-t}"
      y1="${-t}"
      x2="${t}"
      y2="${t}"
    />
  `, i = `
    <line 
      x1="${-t}"
      y1="${t}"
      x2="${t}"
      y2="${-t}"
    />
  `;
  return `<g class="x">${e} ${i}</g>`;
}
function M(o) {
  return Math.min(1, Math.max(o, -1));
}
function z(o) {
  const t = M(o);
  return t > 0 ? `
      height: ${Math.abs(t) / 2 * 100}%;
      top: auto;
      bottom: 50%;
    ` : `
    height: ${Math.abs(t) / 2 * 100}%;
    top: 50%;
    bottom: auto;
  `;
}
const K = class extends T {
  constructor() {
    super(), this.frontLeftMotorSpeed = 0, this.frontRightMotorSpeed = 0, this.rearLeftMotorSpeed = 0, this.rearRightMotorSpeed = 0, new ResizeObserver(() => {
      this.resized();
    }).observe(this);
  }
  drawMotionVector(t, e, i, r) {
    const s = this.renderRoot.querySelector("#svg").getBoundingClientRect(), n = s.width * 0.13, d = 20, a = 20, c = s.width - (n + d) * 2, h = s.height - a * 2, l = Math.min(c, h) / 2 - 16, y = {
      x: (t - e - i + r) / 4,
      y: (t + e + i + r) / 4
    }, v = (-t + e - i + r) / 4, g = Math.hypot(y.x, y.y), S = Math.atan2(y.y, y.x);
    if (Math.abs(v) <= 0.01 && g <= 0.01)
      return lt(s.width * 0.2);
    let x = "", m = "", $ = "";
    return Math.abs(v) > 0.01 && (x = F(
      0,
      l,
      -v * Math.PI,
      0,
      8
    ), m = F(
      Math.PI,
      l,
      -v * Math.PI,
      0,
      8
    )), g > 0.01 && ($ = D(
      g * l,
      -S,
      0,
      8
    )), `<g class="arrow">${x} ${m} ${$}</g>`;
  }
  drawDrivetrain() {
    const t = this.renderRoot.querySelector("#svg").getBoundingClientRect(), e = t.width * 0.13, i = Math.min(t.width * 0.13, t.height * 0.15), r = 20, s = 20, n = `
      <rect 
        width="calc(100% - ${(e + r) * 2}px)" 
        height="calc(100% - ${s * 2}px)"
        x="${e + r}" 
        y="20px" 
      />
    `, d = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="${r}px" 
        y="${s}px" 
      />
    `, a = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="calc(100% - ${e + r}px)" 
        y="${s}px" 
      />
    `, c = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="${r}px"
        y="calc(100% - ${i * 2 + s}px)"
      />
    `, h = `
      <rect 
        width="${e}px" 
        height="${i * 2}" 
        x="calc(100% - ${e + r}px)" 
        y="calc(100% - ${i * 2 + s}px)"
      />
    `;
    return n + d + a + c + h;
  }
  getFlForegroundStyle() {
    return z(this.frontLeftMotorSpeed);
  }
  getFrForegroundStyle() {
    return z(this.frontRightMotorSpeed);
  }
  getRlForegroundStyle() {
    return z(this.rearLeftMotorSpeed);
  }
  getRrForegroundStyle() {
    return z(this.rearRightMotorSpeed);
  }
  firstUpdated() {
    const t = this.drawMotionVector(0, 0, 0, 0);
    this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain(), this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  resized() {
    const t = this.drawMotionVector(
      M(this.frontLeftMotorSpeed),
      M(this.frontRightMotorSpeed),
      M(this.rearLeftMotorSpeed),
      M(this.rearRightMotorSpeed)
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
    const e = this.renderRoot.querySelector("#svg").getBoundingClientRect();
    this.renderRoot.querySelector("#forceVector").style.transform = `translate(${e.width * 0.5}px, ${e.height * 0.5}px)`, this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain();
  }
  updated(t) {
    super.updated(t);
    const e = this.drawMotionVector(
      M(this.frontLeftMotorSpeed),
      M(this.frontRightMotorSpeed),
      M(this.rearLeftMotorSpeed),
      M(this.rearRightMotorSpeed)
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = e;
  }
  render() {
    return O`
      <div class="diff-drive-container">
        <div class="speed-pair">
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getFlForegroundStyle()}"
              ></div>
            </div>
          </div>
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getRlForegroundStyle()}"
              ></div>
            </div>
          </div>
        </div>
        <svg id="svg">
          <g id="forceVector"></g>
          <g id="drivetrain" class="drivetrain"></g>
        </svg>
        <div class="speed-pair">
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getFrForegroundStyle()}"
              ></div>
            </div>
          </div>
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getRrForegroundStyle()}"
              ></div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
};
K.styles = H`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
      padding: 0 10px;
      font-family: sans-serif;
    }

    .diff-drive-container {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
    }

    svg {
      overflow: overlay;
      flex: 1;
      height: 100%;
    }

    svg .x {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
    }

    svg .arrow line,
    svg .arrow path {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
      fill: none;
    }

    svg .arrow polygon {
      stroke: rgb(50, 50, 255);
      fill: rgb(50, 50, 255);
    }

    svg .drivetrain {
      fill: none;
      stroke: var(--frc-mecanum-drivebase-drivetrain-color, #000);
    }

    .bar {
      position: relative;
      height: calc(100% - 30px);
      width: 20px;
      border-radius: 3px;
      margin: 15px 0;
      background: var(--frc-bar-background, #ddd);
    }

    .speed-pair {
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
    }

    .speed {
      display: flex;
      height: 48%;
      flex-direction: row;
      align-items: center;
      margin-left: 30px;
    }

    frc-axis {
      width: 10px;
      height: calc(100% - 35px);
    }

    .foreground {
      position: absolute;
      top: 0;
      width: 20px;
      background: var(--frc-bar-foreground, lightblue);
      border-radius: 3px;
    }
  `;
let R = K;
q([
  u({ type: Number, attribute: "front-left-motor-speed" })
], R.prototype, "frontLeftMotorSpeed");
q([
  u({ type: Number, attribute: "front-right-motor-speed" })
], R.prototype, "frontRightMotorSpeed");
q([
  u({ type: Number, attribute: "rear-left-motor-speed" })
], R.prototype, "rearLeftMotorSpeed");
q([
  u({ type: Number, attribute: "rear-right-motor-speed" })
], R.prototype, "rearRightMotorSpeed");
customElements.get("frc-mecanum-drivebase") || customElements.define("frc-mecanum-drivebase", R);
var gt = Object.defineProperty, f = (o, t, e, i) => {
  for (var r = void 0, s = o.length - 1, n; s >= 0; s--)
    (n = o[s]) && (r = n(t, e, r) || r);
  return r && gt(t, e, r), r;
};
function U(o, ...t) {
  return t.some((e) => o.has(e));
}
function Q(o) {
  return o * Math.PI / 180;
}
function C(o) {
  return o * 180 / Math.PI;
}
function ut(o, t, e) {
  return Math.max(Math.min(o, e), t);
}
function A(o, t = !1) {
  const e = Q(-(o - 90));
  return [t ? -Math.cos(e) : Math.cos(e), Math.sin(e)];
}
const w = 35, X = class extends T {
  constructor() {
    super(...arguments), this.moduleCount = 4, this.wheelLocations = [
      2.5,
      2,
      2.5,
      -2,
      -2.5,
      2,
      -2.5,
      -2
    ], this.measuredStates = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.desiredStates = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.robotRotation = 0, this.maxSpeed = 1, this.rotationUnit = "radians", this.sizeLeftRight = 4, this.sizeFrontBack = 5, this.normalizedRotation = 0;
  }
  drawBase() {
    const [t, e] = this.getBaseSize();
    L(this._base).attr("width", t).attr("height", e).attr("stroke-width", 5).attr("fill", "none");
  }
  setSwerveRotation() {
    L(this._swerve).attr(
      "transform",
      `rotate(${-this.normalizedRotation})`
    );
  }
  setSwerveOrigin() {
    const [t, e] = this.getBaseSize();
    L(this._swerve).attr(
      "transform-origin",
      `${t / 2} ${e / 2}`
    );
  }
  getRobotRotationRad() {
    const t = this.robotRotation;
    return this.rotationUnit === "radians" ? t : Q(t);
  }
  getSvgSize() {
    const { width: t } = this.getBoundingClientRect();
    return [t, t * this.sizeFrontBack / this.sizeLeftRight];
  }
  getBaseSize() {
    const [t] = this.getSvgSize();
    return [t, t * this.sizeFrontBack / this.sizeLeftRight];
  }
  updated(t) {
    if (t.has("robotRotation")) {
      const e = this.robotRotation ?? 0, i = (t.get("robotRotation") ?? e) - e, r = this.rotationUnit === "degrees" ? i : C(i), s = [
        r - 720,
        r - 360,
        r,
        r + 360,
        r + 720
      ];
      let n = 0, d = Math.abs(s[0]);
      for (let a = 1; a < s.length; a += 1) {
        const c = Math.abs(s[a]);
        c < d && (n = a, d = c);
      }
      this.normalizedRotation -= s[n];
    }
    U(
      t,
      "sizeLeftRight",
      "sizeFrontBack",
      "robotRotation",
      "rotationUnit"
    ) && this.drawBase(), U(t, "robotRotation", "rotationUnit") && this.setSwerveRotation(), U(t, "sizeLeftRight", "sizeFrontBack") && this.setSwerveOrigin();
  }
  resized() {
    const [t, e] = this.getSvgSize();
    L(this._svg).attr("width", t).attr("height", e), this.drawBase(), this.setSwerveOrigin(), this.requestUpdate();
  }
  firstUpdated() {
    new ResizeObserver(() => {
      this.resized();
    }).observe(this), this.resized();
  }
  getSwerveModules() {
    const t = [];
    for (let e = 0; e < this.moduleCount; e += 1) {
      const i = {
        location: [
          this.wheelLocations[e * 2],
          this.wheelLocations[e * 2 + 1]
        ],
        desiredRotation: this.desiredStates[e * 2],
        desiredVelocity: this.desiredStates[e * 2 + 1],
        measuredRotation: this.measuredStates[e * 2],
        measuredVelocity: this.measuredStates[e * 2 + 1]
      };
      t.push(i);
    }
    return t;
  }
  renderModuleDirectionIndicator(t, e, i) {
    const r = this.rotationUnit === "degrees" ? e : C(e), [s, n] = A(r - 15, !0), [d, a] = A(r + 15, !0), c = `M ${-s * 60},${n * 60} L 0,0 ${-d * 60},${a * 60}`;
    return b`
      <defs>
        <clipPath id=${t}>
          <path d=${c} fill="white" stroke="5" stroke="white" />
        </clipPath>
      </defs>
      <circle r=${w - 2.5} fill=${i} stroke-width="0" clip-path=${`url(#${t})`}></circle>
    `;
  }
  renderModuleVelocityIndicator(t, e, i, r) {
    const s = this.rotationUnit === "degrees" ? e : C(e);
    let n = ut(100 * i / this.maxSpeed, -100, 100);
    n += w * Math.sign(n), n *= -1;
    const d = Math.abs(n) - 20, a = Math.abs(n), c = `M -17.5,${d} L 2.5,${a} L 22.5,${d}`, h = `rotate(${-s + (n < 0 ? 180 : 0)})`, l = `${t}-velocity`;
    return b`
     <defs>
        <mask id=${l}>
          <circle r="300" fill="white" ></circle>
          <circle r=${w + 2.5} fill="black" ></circle>
        </mask>
      </defs>
      <g class="velocity-indicator" transform=${h} mask="url(#${l})">
        <rect width="5" height=${Math.abs(n)} fill=${r}></rect>
        <path d=${c} stroke=${r} stroke-width="5" fill="none" />
      </g>
    `;
  }
  renderModules() {
    const t = this.getSwerveModules(), [e, i] = this.getBaseSize();
    return b`
      <g class="modules">
        ${t.map((r, s) => {
      const {
        desiredRotation: n,
        measuredRotation: d,
        location: a,
        measuredVelocity: c,
        desiredVelocity: h
      } = r, l = i / 2 * (1 - a[0]) + w * Math.sign(a[0]), y = e / 2 * (a[1] + 1) - w * Math.sign(a[1]), v = `module-${s}-measured-clip`, g = `module-${s}-desired-clip`;
      return b`
            <g transform=${`translate(${y}, ${l})`}>
              <circle class="module-circle" r=${w} stroke-width="5" fill="none"></circle>
              ${this.renderModuleDirectionIndicator(
        v,
        d,
        "blue"
      )}
              ${this.renderModuleDirectionIndicator(
        g,
        n,
        "red"
      )}
              ${this.renderModuleVelocityIndicator(
        v,
        d,
        c,
        "blue"
      )}
              ${this.renderModuleVelocityIndicator(
        g,
        n,
        h,
        "red"
      )}
            </g>
          `;
    })} 
      </g>
    `;
  }
  renderWheelMask() {
    const t = this.getSwerveModules(), [e, i] = this.getBaseSize();
    return b`
      <defs>
        <mask id="wheel-mask">
          <rect fill="white" width=${e} height=${i} stroke-width="5" stroke="white"></rect>
          ${t.map((r) => {
      const s = i / 2 - i * r.location[0] / this.sizeFrontBack, n = e / 2 - e * r.location[1] / this.sizeLeftRight;
      return b`
              <circle r="50" fill="black" transform=${`translate(${n}, ${s})`}></circle>
            `;
    })}
        </mask>
      </defs>
    `;
  }
  renderArrow() {
    const [t, e] = this.getBaseSize(), i = `M ${t / 2 - 30},100 L ${t / 2},70 L ${t / 2 + 30},100`;
    return b`
      <line class="arrow" x1=${t / 2} y1=${70} x2=${t / 2} y2=${e - 30} stroke-width="5" />
      <path class="arrow" d=${i} stroke-width="5" fill="none" />
    `;
  }
  render() {
    return O`
      <div>
        ${b`
          <svg>
            ${this.renderWheelMask()}
            <g class="swerve">
              <rect class="base" rx=${w}></rect>
              ${this.renderModules()}
              ${this.renderArrow()}
            </g>
          </svg>
      `}
      </div>
    `;
  }
};
X.styles = H`
    :host {
      display: inline-block;
      width: 300px;
      height: auto;
      overflow: visible;
    }

    svg {
      width: 100%;
      overflow: visible;
    }

    .base {
      stroke: var(--frc-swerve-drive-color, black);
    }

    .arrow {
      stroke: var(--frc-swerve-drive-color, black);
    }

    .module-circle {
      stroke: var(--frc-swerve-drive-color, black);
    }
  `;
let p = X;
f([
  u({ type: Number, attribute: "module-count" })
], p.prototype, "moduleCount");
f([
  u({ type: Array, attribute: "wheel-locations" })
], p.prototype, "wheelLocations");
f([
  u({ type: Array, attribute: "measured-states" })
], p.prototype, "measuredStates");
f([
  u({ type: Array, attribute: "desired-states" })
], p.prototype, "desiredStates");
f([
  u({ type: Number, attribute: "robot-rotation" })
], p.prototype, "robotRotation");
f([
  u({ type: Number, attribute: "max-speed" })
], p.prototype, "maxSpeed");
f([
  u({ type: String, attribute: "rotation-unit" })
], p.prototype, "rotationUnit");
f([
  u({ type: Number, attribute: "size-left-right" })
], p.prototype, "sizeLeftRight");
f([
  u({ type: Number, attribute: "size-front-back" })
], p.prototype, "sizeFrontBack");
f([
  V("svg")
], p.prototype, "_svg");
f([
  V(".swerve")
], p.prototype, "_swerve");
f([
  V(".base")
], p.prototype, "_base");
f([
  V(".modules")
], p.prototype, "_modules");
customElements.get("frc-swerve-drivebase") || customElements.define("frc-swerve-drivebase", p);
const St = E({
  tagName: "frc-differential-drivebase",
  elementClass: B,
  react: N
}), Rt = E({
  tagName: "frc-mecanum-drivebase",
  elementClass: R,
  react: N
}), kt = E({
  tagName: "frc-swerve-drivebase",
  elementClass: p,
  react: N
});
export {
  St as Differential,
  Rt as Mecanum,
  kt as Swerve
};
