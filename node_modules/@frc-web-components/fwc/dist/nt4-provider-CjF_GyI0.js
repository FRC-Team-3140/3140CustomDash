import { T as I } from "./index.es-3BKgpzRw.js";
function U(l, e) {
  let t, f, r = new Uint8Array(128), c = 0;
  var h = "";
  return w(l, !1, h), r.subarray(0, c);
  function w(s, o, u) {
    switch (typeof s) {
      case "undefined":
        b();
        break;
      case "boolean":
        T(s);
        break;
      case "number":
        y(s, u);
        break;
      case "string":
        m(s);
        break;
      case "object":
        s === null ? b() : s instanceof Date ? d(s) : Array.isArray(s) ? x(s) : s instanceof Uint8Array || s instanceof Uint8ClampedArray ? S(s) : s instanceof Int8Array || s instanceof Int16Array || s instanceof Uint16Array || s instanceof Int32Array || s instanceof Uint32Array || s instanceof Float32Array || s instanceof Float64Array ? x(s) : i(s);
        break;
      default:
        if (!o && e && e.invalidTypeReplacement)
          typeof e.invalidTypeReplacement == "function" || w(e.invalidTypeReplacement, !0, u);
        else
          throw new Error(
            "Invalid argument type: The type '" + typeof s + "' cannot be serialized."
          );
    }
  }
  function b(s) {
    a(192);
  }
  function T(s) {
    a(s ? 195 : 194);
  }
  function y(s, o) {
    var u = o === "int" || isFinite(s) && Math.floor(s) === s && o !== "double" && o !== "float";
    if (u)
      if (s >= 0 && s <= 127)
        a(s);
      else if (s < 0 && s >= -32)
        a(s);
      else if (s > 0 && s <= 255)
        p([204, s]);
      else if (s >= -128 && s <= 127)
        p([208, s]);
      else if (s > 0 && s <= 65535)
        p([205, s >>> 8, s]);
      else if (s >= -32768 && s <= 32767)
        p([209, s >>> 8, s]);
      else if (s > 0 && s <= 4294967295)
        p([206, s >>> 24, s >>> 16, s >>> 8, s]);
      else if (s >= -2147483648 && s <= 2147483647)
        p([210, s >>> 24, s >>> 16, s >>> 8, s]);
      else if (s > 0 && s <= 18446744073709552e3) {
        let g = s / 4294967296, v = s % 4294967296;
        p([
          211,
          g >>> 24,
          g >>> 16,
          g >>> 8,
          g,
          v >>> 24,
          v >>> 16,
          v >>> 8,
          v
        ]);
      } else s >= -9223372036854776e3 && s <= 9223372036854776e3 ? (a(211), C(s)) : s < 0 ? p([211, 128, 0, 0, 0, 0, 0, 0, 0]) : p([207, 255, 255, 255, 255, 255, 255, 255, 255]);
    else
      f || (t = new ArrayBuffer(8), f = new DataView(t)), f.setFloat64(0, s), a(203), p(new Uint8Array(t));
  }
  function m(s) {
    let o = D(s), u = o.length;
    u <= 31 ? a(160 + u) : u <= 255 ? p([217, u]) : u <= 65535 ? p([218, u >>> 8, u]) : p([219, u >>> 24, u >>> 16, u >>> 8, u]), p(o);
  }
  function x(s) {
    let o = s.length;
    o <= 15 ? a(144 + o) : o <= 65535 ? p([220, o >>> 8, o]) : p([221, o >>> 24, o >>> 16, o >>> 8, o]);
    for (let u = 0; u < o; u++)
      w(s[u]);
  }
  function S(s) {
    let o = s.length;
    o <= 15 ? p([196, o]) : o <= 65535 ? p([197, o >>> 8, o]) : p([198, o >>> 24, o >>> 16, o >>> 8, o]), p(s);
  }
  function i(s) {
    let o = 0;
    for (let u in s)
      s[u] !== void 0 && o++;
    o <= 15 ? a(128 + o) : o <= 65535 ? p([222, o >>> 8, o]) : p([223, o >>> 24, o >>> 16, o >>> 8, o]);
    for (let u in s) {
      let g = s[u];
      g !== void 0 && (w(u), w(g));
    }
  }
  function d(s) {
    let o = s.getTime() / 1e3;
    if (s.getMilliseconds() === 0 && o >= 0 && o < 4294967296)
      p([214, 255, o >>> 24, o >>> 16, o >>> 8, o]);
    else if (o >= 0 && o < 17179869184) {
      let u = s.getMilliseconds() * 1e6;
      p([
        215,
        255,
        u >>> 22,
        u >>> 14,
        u >>> 6,
        u << 2 >>> 0 | o / 4294967296,
        o >>> 24,
        o >>> 16,
        o >>> 8,
        o
      ]);
    } else {
      let u = s.getMilliseconds() * 1e6;
      p([199, 12, 255, u >>> 24, u >>> 16, u >>> 8, u]), C(o);
    }
  }
  function a(s) {
    if (r.length < c + 1) {
      let o = r.length * 2;
      for (; o < c + 1; ) o *= 2;
      let u = new Uint8Array(o);
      u.set(r), r = u;
    }
    r[c] = s, c++;
  }
  function p(s) {
    if (r.length < c + s.length) {
      let o = r.length * 2;
      for (; o < c + s.length; ) o *= 2;
      let u = new Uint8Array(o);
      u.set(r), r = u;
    }
    r.set(s, c), c += s.length;
  }
  function C(s) {
    let o, u;
    s >= 0 ? (o = s / 4294967296, u = s % 4294967296) : (s++, o = Math.abs(s) / 4294967296, u = Math.abs(s) % 4294967296, o = ~o, u = ~u), p([
      o >>> 24,
      o >>> 16,
      o >>> 8,
      o,
      u >>> 24,
      u >>> 16,
      u >>> 8,
      u
    ]);
  }
}
function E(l, e) {
  let t = 0;
  if (l instanceof ArrayBuffer && (l = new Uint8Array(l)), typeof l != "object" || typeof l.length > "u")
    throw new Error(
      "Invalid argument type: Expected a byte array (Array or Uint8Array) to deserialize."
    );
  if (!l.length)
    throw new Error(
      "Invalid argument: The byte array to deserialize is empty."
    );
  l instanceof Uint8Array || (l = new Uint8Array(l));
  let f;
  if (e && e.multiple)
    for (f = []; t < l.length; )
      f.push(r());
  else
    f = r();
  return f;
  function r() {
    const i = l[t++];
    if (i >= 0 && i <= 127) return i;
    if (i >= 128 && i <= 143) return T(i - 128);
    if (i >= 144 && i <= 159) return y(i - 144);
    if (i >= 160 && i <= 191) return m(i - 160);
    if (i === 192) return null;
    if (i === 193) throw new Error("Invalid byte code 0xc1 found.");
    if (i === 194) return !1;
    if (i === 195) return !0;
    if (i === 196) return b(-1, 1);
    if (i === 197) return b(-1, 2);
    if (i === 198) return b(-1, 4);
    if (i === 199) return x(-1, 1);
    if (i === 200) return x(-1, 2);
    if (i === 201) return x(-1, 4);
    if (i === 202) return w(4);
    if (i === 203) return w(8);
    if (i === 204) return h(1);
    if (i === 205) return h(2);
    if (i === 206) return h(4);
    if (i === 207) return h(8);
    if (i === 208) return c(1);
    if (i === 209) return c(2);
    if (i === 210) return c(4);
    if (i === 211) return c(8);
    if (i === 212) return x(1);
    if (i === 213) return x(2);
    if (i === 214) return x(4);
    if (i === 215) return x(8);
    if (i === 216) return x(16);
    if (i === 217) return m(-1, 1);
    if (i === 218) return m(-1, 2);
    if (i === 219) return m(-1, 4);
    if (i === 220) return y(-1, 2);
    if (i === 221) return y(-1, 4);
    if (i === 222) return T(-1, 2);
    if (i === 223) return T(-1, 4);
    if (i >= 224 && i <= 255) return i - 256;
    throw console.debug("msgpack array:", l), new Error(
      "Invalid byte value '" + i + "' at index " + (t - 1) + " in the MessagePack binary data (length " + l.length + "): Expecting a range of 0 to 255. This is not a byte array."
    );
  }
  function c(i) {
    let d = 0, a = !0;
    for (; i-- > 0; )
      if (a) {
        let p = l[t++];
        d += p & 127, p & 128 && (d -= 128), a = !1;
      } else
        d *= 256, d += l[t++];
    return d;
  }
  function h(i) {
    let d = 0;
    for (; i-- > 0; )
      d *= 256, d += l[t++];
    return d;
  }
  function w(i) {
    let d = new DataView(l.buffer, t + l.byteOffset, i);
    if (t += i, i === 4) return d.getFloat32(0, !1);
    if (i === 8) return d.getFloat64(0, !1);
  }
  function b(i, d) {
    i < 0 && (i = h(d));
    let a = l.subarray(t, t + i);
    return t += i, a;
  }
  function T(i, d) {
    i < 0 && (i = h(d));
    let a = {};
    for (; i-- > 0; ) {
      let p = r();
      a[p] = r();
    }
    return a;
  }
  function y(i, d) {
    i < 0 && (i = h(d));
    let a = [];
    for (; i-- > 0; )
      a.push(r());
    return a;
  }
  function m(i, d) {
    i < 0 && (i = h(d));
    let a = t;
    return t += i, j(l, a, i);
  }
  function x(i, d) {
    i < 0 && (i = h(d));
    let a = h(1), p = b(i);
    switch (a) {
      case 255:
        return S(p);
    }
    return { type: a, data: p };
  }
  function S(i) {
    if (i.length === 4) {
      let d = (i[0] << 24 >>> 0) + (i[1] << 16 >>> 0) + (i[2] << 8 >>> 0) + i[3];
      return new Date(d * 1e3);
    }
    if (i.length === 8) {
      let d = (i[0] << 22 >>> 0) + (i[1] << 14 >>> 0) + (i[2] << 6 >>> 0) + (i[3] >>> 2), a = (i[3] & 3) * 4294967296 + (i[4] << 24 >>> 0) + (i[5] << 16 >>> 0) + (i[6] << 8 >>> 0) + i[7];
      return new Date(a * 1e3 + d / 1e6);
    }
    if (i.length === 12) {
      let d = (i[0] << 24 >>> 0) + (i[1] << 16 >>> 0) + (i[2] << 8 >>> 0) + i[3];
      t -= 8;
      let a = c(8);
      return new Date(a * 1e3 + d / 1e6);
    }
    throw new Error("Invalid data length for a date value.");
  }
}
function D(l) {
  let e = !0, n = l.length;
  for (let r = 0; r < n; r++)
    if (l.charCodeAt(r) > 127) {
      e = !1;
      break;
    }
  let t = 0, f = new Uint8Array(l.length * (e ? 1 : 4));
  for (let r = 0; r !== n; r++) {
    let c = l.charCodeAt(r);
    if (c < 128) {
      f[t++] = c;
      continue;
    }
    if (c < 2048)
      f[t++] = c >> 6 | 192;
    else {
      if (c > 55295 && c < 56320) {
        if (++r >= n)
          throw new Error("UTF-8 encode: incomplete surrogate pair");
        let h = l.charCodeAt(r);
        if (h < 56320 || h > 57343)
          throw new Error(
            "UTF-8 encode: second surrogate character 0x" + h.toString(16) + " at index " + r + " out of range"
          );
        c = 65536 + ((c & 1023) << 10) + (h & 1023), f[t++] = c >> 18 | 240, f[t++] = c >> 12 & 63 | 128;
      } else f[t++] = c >> 12 | 224;
      f[t++] = c >> 6 & 63 | 128;
    }
    f[t++] = c & 63 | 128;
  }
  return e ? f : f.subarray(0, t);
}
function j(l, e, n) {
  let t = e, f = "";
  for (n += e; t < n; ) {
    let r = l[t++];
    if (r > 127)
      if (r > 191 && r < 224) {
        if (t >= n)
          throw new Error("UTF-8 decode: incomplete 2-byte sequence");
        r = (r & 31) << 6 | l[t++] & 63;
      } else if (r > 223 && r < 240) {
        if (t + 1 >= n)
          throw new Error("UTF-8 decode: incomplete 3-byte sequence");
        r = (r & 15) << 12 | (l[t++] & 63) << 6 | l[t++] & 63;
      } else if (r > 239 && r < 248) {
        if (t + 2 >= n)
          throw new Error("UTF-8 decode: incomplete 4-byte sequence");
        r = (r & 7) << 18 | (l[t++] & 63) << 12 | (l[t++] & 63) << 6 | l[t++] & 63;
      } else
        throw new Error(
          "UTF-8 decode: unknown multibyte start 0x" + r.toString(16) + " at index " + (t - 1)
        );
    if (r <= 65535) f += String.fromCharCode(r);
    else if (r <= 1114111)
      r -= 65536, f += String.fromCharCode(r >> 10 | 55296), f += String.fromCharCode(r & 1023 | 56320);
    else
      throw new Error(
        "UTF-8 decode: code point 0x" + r.toString(16) + " exceeds UTF-16 reach"
      );
  }
  return f;
}
const N = {
  boolean: 0,
  double: 1,
  int: 2,
  float: 3,
  string: 4,
  json: 4,
  raw: 5,
  rpc: 5,
  msgpack: 5,
  protobuf: 5,
  "boolean[]": 16,
  "double[]": 17,
  "int[]": 18,
  "float[]": 19,
  "string[]": 20
};
class A {
  constructor() {
    this.uid = -1, this.topics = /* @__PURE__ */ new Set(), this.options = new F();
  }
  toSubscribeObj() {
    return {
      topics: Array.from(this.topics),
      subuid: this.uid,
      options: this.options.toObj()
    };
  }
  toUnsubscribeObj() {
    return {
      subuid: this.uid
    };
  }
}
class F {
  constructor() {
    this.periodic = 0.02, this.all = !1, this.topicsOnly = !1, this.prefix = !1;
  }
  toObj() {
    return {
      periodic: this.periodic,
      all: this.all,
      topicsonly: this.topicsOnly,
      prefix: this.prefix
    };
  }
}
class O {
  constructor() {
    this.uid = -1, this.name = "", this.type = "", this.properties = {};
  }
  toPublishObj() {
    return {
      name: this.name,
      type: this.type,
      pubuid: this.uid,
      properties: this.properties
    };
  }
  toUnpublishObj() {
    return {
      pubuid: this.uid
    };
  }
  getTypeIdx() {
    return this.type in N ? N[this.type] : 5;
  }
}
class k {
  /**
   * Creates a new NT4 client without connecting.
   * @param serverAddr Network address of NT4 server
   * @param appName Identifier for this client (does not need to be unique).
   * @param onTopicAnnounce Gets called when server announces enough topics to form a new signal
   * @param onTopicUnannounce Gets called when server unannounces any part of a signal
   * @param onNewTopicData Gets called when any new data is available
   * @param onConnect Gets called once client completes initial handshake with server
   * @param onDisconnect Gets called once client detects server has disconnected
   */
  constructor(e, n, t, f, r, c, h) {
    this.ws = null, this.clientIdx = 0, this.useSecure = !1, this.serverAddr = "", this.serverConnectionActive = !1, this.serverConnectionRequested = !1, this.serverTimeOffset_us = null, this.uidCounter = 0, this.subscriptions = /* @__PURE__ */ new Map(), this.publishedTopics = /* @__PURE__ */ new Map(), this.serverTopics = /* @__PURE__ */ new Map(), this.serverBaseAddr = e, this.appName = n, this.onTopicAnnounce = t, this.onTopicUnannounce = f, this.onNewTopicData = r, this.onConnect = c, this.onDisconnect = h, setInterval(() => this.ws_sendTimestamp(), 5e3);
  }
  //////////////////////////////////////////////////////////////
  // PUBLIC API
  /** Starts the connection. The client will reconnect automatically when disconnected. */
  connect() {
    this.serverConnectionRequested || (this.serverConnectionRequested = !0, this.ws_connect());
  }
  /** Terminates the connection. */
  disconnect() {
    this.serverConnectionRequested && (this.serverConnectionRequested = !1, this.serverConnectionActive && this.ws && this.ws.close());
  }
  /**
   * Add a new subscription, reading data at the specified frequency.
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @param period The period to return data in seconds.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribePeriodic(e, n, t) {
    let f = new A();
    return f.uid = this.getNewUID(), f.topics = new Set(e), f.options.prefix = n, f.options.periodic = t, this.subscriptions.set(f.uid, f), this.serverConnectionActive && this.ws_subscribe(f), f.uid;
  }
  /**
   * Add a new subscription, reading all value updates.
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribeAll(e, n) {
    let t = new A();
    return t.uid = this.getNewUID(), t.topics = new Set(e), t.options.prefix = n, t.options.all = !0, this.subscriptions.set(t.uid, t), this.serverConnectionActive && this.ws_subscribe(t), t.uid;
  }
  /**
   * Add a new subscription, reading only topic announcements (not values).
   * @param topicPatterns A list of topics or prefixes to include in the subscription.
   * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
   * @returns A subscription ID that can be used to unsubscribe.
   */
  subscribeTopicsOnly(e, n) {
    let t = new A();
    return t.uid = this.getNewUID(), t.topics = new Set(e), t.options.prefix = n, t.options.topicsOnly = !0, this.subscriptions.set(t.uid, t), this.serverConnectionActive && this.ws_subscribe(t), t.uid;
  }
  /** Given an existing subscription, unsubscribe from it. */
  unsubscribe(e) {
    let n = this.subscriptions.get(e);
    if (!n)
      throw 'Unknown subscription ID "' + e + '"';
    this.subscriptions.delete(e), this.serverConnectionActive && this.ws_unsubscribe(n);
  }
  /** Unsubscribe from all current subscriptions. */
  clearAllSubscriptions() {
    for (const e of this.subscriptions.keys())
      this.unsubscribe(e);
  }
  /**
   * Set the properties of a particular topic.
   * @param topic The topic to update
   * @param properties The set of new properties
   */
  setProperties(e, n) {
    let t = (c) => {
      for (const h of Object.keys(n)) {
        let w = n[h];
        w === null ? delete c.properties[h] : c.properties[h] = w;
      }
    }, f = this.publishedTopics.get(e);
    f && t(f);
    let r = this.serverTopics.get(e);
    r && t(r), this.serverConnectionActive && this.ws_setproperties(e, n);
  }
  /** Set whether a topic is persistent.
   *
   * If true, the last set value will be periodically saved to
   * persistent storage on the server and be restored during server
   * startup. Topics with this property set to true will not be
   * deleted by the server when the last publisher stops publishing.
   */
  setPersistent(e, n) {
    this.setProperties(e, { persistent: n });
  }
  /** Set whether a topic is retained.
   *
   * Topics with this property set to true will not be deleted by
   * the server when the last publisher stops publishing.
   */
  setRetained(e, n) {
    this.setProperties(e, { retained: n });
  }
  /** Publish a new topic from this client with the provided name and type. */
  publishNewTopic(e, n) {
    if (this.publishedTopics.has(e))
      return;
    let t = new O();
    t.name = e, t.uid = this.getNewUID(), t.type = n, this.publishedTopics.set(e, t), this.serverConnectionActive && this.ws_publish(t);
  }
  /** Unpublish a previously-published topic from this client. */
  unpublishTopic(e) {
    let n = this.publishedTopics.get(e);
    if (!n)
      throw 'Topic "' + e + '" not found';
    this.publishedTopics.delete(e), this.serverConnectionActive && this.ws_unpublish(n);
  }
  /** Send some new value to the server. The timestamp is whatever the current time is. */
  addSample(e, n) {
    let t = this.getServerTime_us();
    t === null && (t = 0), this.addTimestampedSample(e, t, n);
  }
  /** Send some new timestamped value to the server. */
  addTimestampedSample(e, n, t) {
    let f = this.publishedTopics.get(e);
    if (!f)
      throw 'Topic "' + e + '" not found';
    let r = U([
      f.uid,
      n,
      f.getTypeIdx(),
      t
    ]);
    this.ws_sendBinary(r);
  }
  //////////////////////////////////////////////////////////////
  // Server/Client Time Sync Handling
  /** Returns the current client time in microseconds. */
  getClientTime_us() {
    return (/* @__PURE__ */ new Date()).getTime() * 1e3;
  }
  /** Returns the current server time in microseconds (or null if unknown). */
  getServerTime_us() {
    return this.serverTimeOffset_us === null ? null : this.getClientTime_us() + this.serverTimeOffset_us;
  }
  ws_sendTimestamp() {
    let e = this.getClientTime_us(), n = U([-1, 0, N.int, e]);
    this.ws_sendBinary(n);
  }
  ws_handleReceiveTimestamp(e, n) {
    let t = this.getClientTime_us(), f = t - n, r = e + f / 2;
    this.serverTimeOffset_us = r - t, console.log(
      "[NT4] New server time estimate: " + (this.getServerTime_us() / 1e6).toString()
    );
  }
  //////////////////////////////////////////////////////////////
  // Websocket Message Send Handlers
  ws_subscribe(e) {
    this.ws_sendJSON("subscribe", e.toSubscribeObj());
  }
  ws_unsubscribe(e) {
    this.ws_sendJSON("unsubscribe", e.toUnsubscribeObj());
  }
  ws_publish(e) {
    this.ws_sendJSON("publish", e.toPublishObj());
  }
  ws_unpublish(e) {
    this.ws_sendJSON("unpublish", e.toUnpublishObj());
  }
  ws_setproperties(e, n) {
    this.ws_sendJSON("setproperties", {
      name: e,
      update: n
    });
  }
  ws_sendJSON(e, n) {
    this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(
      JSON.stringify([
        {
          method: e,
          params: n
        }
      ])
    );
  }
  ws_sendBinary(e) {
    this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(e);
  }
  //////////////////////////////////////////////////////////////
  // Websocket connection Maintenance
  ws_onOpen() {
    this.serverConnectionActive = !0, console.log("[NT4] Connected with idx " + this.clientIdx.toString()), this.ws_sendTimestamp();
    for (const e of this.publishedTopics.values())
      this.ws_publish(e);
    for (const e of this.subscriptions.values())
      this.ws_subscribe(e);
    this.onConnect();
  }
  ws_onClose(e) {
    this.ws = null, this.serverConnectionActive = !1, this.onDisconnect(), this.serverTopics.clear(), e.reason !== "" && console.log("[NT4] Socket is closed: ", e.reason), this.serverConnectionRequested && setTimeout(() => this.ws_connect(), 500);
  }
  ws_onError() {
    this.ws && this.ws.close();
  }
  ws_onMessage(e) {
    if (typeof e.data == "string") {
      let n = JSON.parse(e.data);
      if (!Array.isArray(n)) {
        console.warn(
          "[NT4] Ignoring text message, JSON parsing did not produce an array at the top level."
        );
        return;
      }
      n.forEach((t) => {
        if (typeof t != "object") {
          console.warn(
            "[NT4] Ignoring text message, JSON parsing did not produce an object."
          );
          return;
        }
        if (!("method" in t) || !("params" in t)) {
          console.warn(
            "[NT4] Ignoring text message, JSON parsing did not find all required fields."
          );
          return;
        }
        let f = t.method, r = t.params;
        if (typeof f != "string") {
          console.warn(
            `[NT4] Ignoring text message, JSON parsing found "method", but it wasn't a string.`
          );
          return;
        }
        if (typeof r != "object") {
          console.warn(
            `[NT4] Ignoring text message, JSON parsing found "params", but it wasn't an object.`
          );
          return;
        }
        if (f === "announce") {
          let c = new O();
          c.uid = r.id, c.name = r.name, c.type = r.type, c.properties = r.properties, this.serverTopics.set(c.name, c), this.onTopicAnnounce(c);
        } else if (f === "unannounce") {
          let c = this.serverTopics.get(r.name);
          if (!c) {
            console.warn(
              "[NT4] Ignoring unannounce, topic was not previously announced."
            );
            return;
          }
          this.serverTopics.delete(c.name), this.onTopicUnannounce(c);
        } else if (f === "properties") {
          let c = this.serverTopics.get(r.name);
          if (!c) {
            console.warn(
              "[NT4] Ignoring set properties, topic was not previously announced."
            );
            return;
          }
          for (const h of Object.keys(r.update)) {
            let w = r.update[h];
            w === null ? delete c.properties[h] : c.properties[h] = w;
          }
        } else {
          console.warn(
            "[NT4] Ignoring text message - unknown method " + f
          );
          return;
        }
      });
    } else
      E(e.data, { multiple: !0 }).forEach(
        (n) => {
          let t = n[0], f = n[1], r = n[3];
          if (t >= 0) {
            let c = null;
            for (let h of this.serverTopics.values())
              h.uid === t && (c = h);
            if (!c) {
              console.warn(
                "[NT4] Ignoring binary data - unknown topic ID " + t.toString()
              );
              return;
            }
            this.onNewTopicData(c, f, r);
          } else t === -1 ? this.ws_handleReceiveTimestamp(f, r) : console.warn(
            "[NT4] Ignoring binary data - invalid topic ID " + t.toString()
          );
        }
      );
  }
  ws_connect() {
    this.clientIdx = Math.floor(Math.random() * 99999999);
    let e = 5810, n = "ws://";
    this.useSecure && (n = "wss://", e = 5811), this.serverAddr = n + this.serverBaseAddr + ":" + e.toString() + "/nt/" + this.appName + "_" + this.clientIdx.toString(), this.ws = new WebSocket(this.serverAddr, "networktables.first.wpi.edu"), this.ws.binaryType = "arraybuffer", this.ws.addEventListener("open", () => this.ws_onOpen()), this.ws.addEventListener(
      "message",
      (t) => this.ws_onMessage(t)
    ), this.ws.addEventListener(
      "close",
      (t) => this.ws_onClose(t)
    ), this.ws.addEventListener("error", () => this.ws_onError());
  }
  //////////////////////////////////////////////////////////////
  // General utilties
  getNewUID() {
    return this.uidCounter++, this.uidCounter + this.clientIdx;
  }
}
function _(l) {
  if (typeof l == "boolean" || typeof l == "string")
    return typeof l;
  if (typeof l == "number")
    return "double";
  if (l instanceof Array) {
    if (l.length === 0)
      return;
    const e = _(l[0]);
    return l.some((t) => _(t) !== e) ? void 0 : `${e}[]`;
  }
}
function R(l) {
  const e = l.toString().at(-4) ?? "", n = l.toString().at(-3) ?? "", t = l.toString().at(-2) ?? "", f = l.toString().at(-1) ?? "";
  let r = parseInt(`${e}${n}`, 10), c = parseInt(`${t}${f}`, 10);
  Number.isNaN(r) && (r = 0), Number.isNaN(c) && (c = 0);
  const h = e + n + t + f;
  return [
    `10.${r.toString()}.${c.toString()}.2`,
    "172.22.11.2",
    `roborio-${h}-FRC.local`,
    `roborio-${h}-FRC.lan`,
    `roborio-${h}-FRC.frc-field.local`
  ];
}
class B extends I {
  constructor() {
    super({}, 1e3 / 60), this.serverAddress = "", this.clients = {}, this.connected = !1, this.topics = {}, this.topicValues = {}, this.unprocessedUpdates = {}, this.connectionListeners = [], this.connect(localStorage.getItem("nt4Address") ?? "127.0.0.1");
  }
  setValue(e, n) {
    this.userUpdate(e, n);
  }
  getValue(e, n) {
    return e in this.topicValues ? this.topicValues[e] : n;
  }
  getServerAddress() {
    return this.serverAddress;
  }
  connect(e) {
    this.serverAddress !== e && (this.clearSources(), this.createClient(e));
  }
  disconnect() {
    var e;
    (e = this.client) == null || e.disconnect();
  }
  isConnected() {
    return this.connected;
  }
  addConnectionListener(e, n = !1) {
    this.connectionListeners.push(e), n && e(this.connected, this.serverAddress);
  }
  processUnprocessedUpdates() {
    const e = { ...this.unprocessedUpdates };
    this.unprocessedUpdates = {}, Object.entries(e).forEach(([n, t]) => {
      this.userUpdate(n, t);
    });
  }
  // TODO: Be able to optionally pass in additional data
  userUpdate(e, n) {
    if (!this.client) {
      this.unprocessedUpdates[e] = n;
      return;
    }
    const t = this.topics[e];
    if (t)
      this.client.publishNewTopic(t.name, t.type), this.client.addSample(t.name, n), this.updateSource(t.name, n);
    else {
      const f = _(n);
      f !== void 0 && (this.client.publishNewTopic(e, f), this.client.addSample(e, n), this.updateSource(e, n));
    }
  }
  onTopicAnnounce(e) {
    this.topics[e.name] = e;
  }
  onTopicUnannounce(e) {
    delete this.topics[e.name], delete this.topicValues[e.name], this.removeSource(e.name);
  }
  onNewTopicData(e, n, t) {
    this.updateSource(e.name, t), this.topicValues[e.name] = t;
  }
  onConnect() {
    this.connected = !0, this.connectionListeners.forEach(
      (e) => e(!0, this.serverAddress)
    ), this.processUnprocessedUpdates();
  }
  onDisconnect() {
    this.connected = !1, this.connectionListeners.forEach(
      (e) => e(!1, this.serverAddress)
    );
  }
  createClient(e) {
    this.client && (this.client.disconnect(), this.topics = {}, this.topicValues = {}, this.connected = !1, this.client = void 0), Object.values(this.clients).forEach((c) => c.disconnect()), this.clients = {}, this.serverAddress = e, this.connectionListeners.forEach(
      (c) => c(this.connected, this.serverAddress)
    ), localStorage.setItem("nt4Address", e);
    const n = "FRC Web Components";
    (/^[0-9]+$/.test(e) && !Number.isNaN(parseFloat(e)) ? R(parseFloat(e)) : [e]).forEach((c) => {
      const h = new k(
        c,
        n,
        (...w) => {
          this.client === h && this.onTopicAnnounce(...w);
        },
        (...w) => {
          this.client === h && this.onTopicUnannounce(...w);
        },
        (...w) => {
          this.client === h && this.onNewTopicData(...w);
        },
        () => {
          this.client = h, Object.entries(this.clients).forEach(
            ([w, b]) => {
              w !== c && b.disconnect();
            }
          ), this.clients = {}, this.onConnect();
        },
        () => {
          this.client === h && this.onDisconnect();
        }
      );
      this.clients[c] = h, h.connect(), h.subscribeAll(["/"], !0);
    });
  }
}
export {
  B as N,
  k as a,
  O as b
};
