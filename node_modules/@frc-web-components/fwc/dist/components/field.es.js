var H = (p) => {
  throw TypeError(p);
};
var _ = (p, i, t) => i.has(p) || H("Cannot " + t);
var b = (p, i, t) => (_(p, i, "read from private field"), t ? t.call(p) : i.get(p)), R = (p, i, t) => i.has(p) ? H("Cannot add the same private member more than once") : i instanceof WeakSet ? i.add(p) : i.set(p, t), I = (p, i, t, s) => (_(p, i, "write to private field"), s ? s.call(p, t) : i.set(p, t), t), X = (p, i, t) => (_(p, i, "access private method"), t);
import { r as j, n as h, i as q, x as L } from "../property-C4BPH-wS.js";
import { e as B } from "../query-BrpQj_Qi.js";
import { b as D, c as y, t as M } from "../units-DyibxdHs.js";
import { u as xt } from "../units-DyibxdHs.js";
import { r as A } from "../state-Cn3aen3G.js";
import { g as E, t as et } from "../index-BXxACewW.js";
const T = [
  // https://www.chiefdelphi.com/t/4k-field-image-2025-reefscape/478797
  {
    game: "Reefscape",
    image: "./field-images/2025-field.jpg",
    corners: {
      topLeft: [421, 91],
      bottomRight: [3352, 1437]
    },
    size: [57.57291667, 26.4167],
    unit: "foot"
  },
  // Thanks to MikLast for providing the 2024 field image here:
  // https://www.chiefdelphi.com/t/2024-crescendo-top-down-field-renders/447764
  {
    game: "Crescendo",
    image: "./field-images/2024-field.jpg",
    corners: {
      topLeft: [513, 78],
      bottomRight: [3327, 1475]
    },
    size: [54.265092, 26.31234],
    unit: "foot"
  },
  {
    game: "Charged Up",
    image: "./field-images/2023-field.jpg",
    corners: {
      topLeft: [46, 36],
      bottomRight: [1088, 544]
    },
    size: [54.27083, 26.2916],
    unit: "foot"
  },
  {
    game: "Rapid React",
    image: "./field-images/2022-field.jpg",
    corners: {
      topLeft: [74, 50],
      bottomRight: [1774, 900]
    },
    size: [54, 27],
    unit: "foot"
  },
  {
    game: "Infinite Recharge",
    image: "./field-images/2020-field.jpg",
    corners: {
      topLeft: [96, 25],
      bottomRight: [1040, 514]
    },
    size: [52.4375, 26.9375],
    unit: "foot"
  },
  {
    game: "Destination: Deep Space",
    image: "./field-images/2019-field.jpg",
    corners: {
      topLeft: [217, 40],
      bottomRight: [1372, 615]
    },
    size: [54, 27],
    unit: "foot"
  },
  {
    game: "FIRST Power Up",
    image: "./field-images/2018-field.jpg",
    corners: {
      topLeft: [125, 20],
      bottomRight: [827, 370]
    },
    size: [54, 27],
    unit: "feet"
  },
  {
    game: "Barrel Racing Path",
    image: "./field-images/2021-barrel.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Bounce Path",
    image: "./field-images/2021-bounce.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Galactic Search A",
    image: "./field-images/2021-galacticsearcha.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Galactic Search B",
    image: "./field-images/2021-galacticsearchb.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  },
  {
    game: "Slalom Path",
    image: "./field-images/2021-slalom.png",
    corners: {
      topLeft: [20, 20],
      bottomRight: [780, 400]
    },
    size: [30, 15],
    unit: "feet"
  }
];
var N, F;
class $ {
  constructor() {
    R(this, N, {});
    R(this, F, /* @__PURE__ */ new Map());
  }
  getImage(i) {
    if (typeof b(this, N)[i] > "u") {
      const t = new Image(), s = {
        src: i,
        width: 0,
        height: 0,
        loaded: !1,
        image: t
      };
      t.onload = () => {
        s.loaded = !0, s.width = t.width, s.height = t.height, [...b(this, F).values()].forEach((e) => {
          e(i);
        });
      }, b(this, N)[i] = s, t.src = i;
    }
    return b(this, N)[i];
  }
  static getBoundingBoxDims(i, t) {
    const s = Math.abs(i.width * Math.cos(t)) + Math.abs(i.height * Math.sin(t)), e = Math.abs(i.width * Math.sin(t)) + Math.abs(i.height * Math.cos(t));
    return {
      width: s,
      height: e
    };
  }
  static fitImageInsideBox(i, t) {
    return t.width / i.width * i.height <= t.height ? {
      width: t.width,
      height: t.width / i.width * i.height
    } : {
      width: t.height / i.height * i.width,
      height: t.height
    };
  }
  onImageLoad(i) {
    const t = Symbol("image");
    return b(this, F).set(t, i), () => {
      b(this, F).delete(t);
    };
  }
}
N = new WeakMap(), F = new WeakMap();
var it = Object.defineProperty, S = (p, i, t, s) => {
  for (var e = void 0, o = p.length - 1, r; o >= 0; o--)
    (r = p[o]) && (e = r(i, t, e) || e);
  return e && it(i, t, e), e;
};
class C extends j {
  constructor() {
    super(...arguments), this.unit = "inherit", this.rotationUnit = "inherit", this.image = "", this.color = "#0000ff", this.opacity = 1, this.pose = [0, 0, 0], this.width = 0.6, this.length = 0.9;
  }
  draw({
    canvas: i,
    unit: t,
    rotationUnit: s,
    xToPx: e,
    yToPx: o,
    lengthToPx: r,
    origin: a
  }) {
    const n = this.unit === "inherit" || this.unit === null ? t : this.unit, u = this.rotationUnit === "inherit" || this.rotationUnit === null ? s : this.rotationUnit, [g, f] = this.pose, m = u === "rad" ? this.pose[2] : this.pose[2] / (180 / Math.PI);
    i.globalAlpha = Math.max(0, Math.min(1, this.opacity)), i.fillStyle = "#222", i.strokeStyle = this.color, i.lineWidth = r(3, "in"), i.translate(e(g, n), o(f, n)), i.rotate(-m + (a === "red" ? Math.PI : 0)), i.roundRect(
      -r(this.length / 2, n),
      -r(this.width / 2, n),
      r(this.length, n),
      r(this.width, n),
      1
    ), i.fill(), i.stroke(), i.beginPath(), i.fillStyle = "white", i.strokeStyle = "white", i.lineWidth = r(2, "in"), i.moveTo(-r(this.length * 0.3, n), 0), i.lineTo(r(this.length * 0.3, n), 0), i.moveTo(
      r(this.length * 0.1, n),
      -r(this.width * 0.25, n)
    ), i.lineTo(r(this.length * 0.3, n), 0), i.lineTo(
      r(this.length * 0.1, n),
      r(this.width * 0.25, n)
    ), i.stroke();
  }
}
S([
  h({ type: String })
], C.prototype, "unit");
S([
  h({ type: String, attribute: "rotation-unit" })
], C.prototype, "rotationUnit");
S([
  h({ type: String })
], C.prototype, "image");
S([
  h({ type: String })
], C.prototype, "color");
S([
  h({ type: Number })
], C.prototype, "opacity");
S([
  h({ type: Array })
], C.prototype, "pose");
S([
  h({ type: Number })
], C.prototype, "width");
S([
  h({ type: Number })
], C.prototype, "length");
customElements.get("frc-field-robot") || customElements.define("frc-field-robot", C);
var ot = Object.defineProperty, v = (p, i, t, s) => {
  for (var e = void 0, o = p.length - 1, r; o >= 0; o--)
    (r = p[o]) && (e = r(i, t, e) || e);
  return e && ot(i, t, e), e;
};
class P extends j {
  constructor() {
    super(...arguments), this.poses = [], this.translations = [], this.color = "#FFA500", this.unit = "inherit", this.lineWidth = 4, this.opacity = 0.7, this._poses = [], this._translations = [];
  }
  updated(i) {
    var t;
    i.has("poses") && (typeof ((t = this.poses) == null ? void 0 : t[0]) == "number" || this.poses instanceof Uint8Array ? this._poses = E(this.poses) : this._poses = this.poses), i.has("translations") && (this._translations = E(this.translations, 2));
  }
  draw({ canvas: i, unit: t, xToPx: s, yToPx: e }) {
    const o = this.unit === "inherit" || this.unit === null ? t : this.unit;
    if (i.lineWidth = this.lineWidth, i.strokeStyle = this.color, i.globalAlpha = this.opacity, this._poses.length > 1) {
      for (let r = 0; r < this._poses.length - 1; r += 1) {
        const [a, n] = this._poses[r], [u, g] = this._poses[r + 1];
        i.moveTo(s(a, o), e(n, o)), i.lineTo(s(u, o), e(g, o));
      }
      i.stroke();
    }
    if (this._translations.length > 1) {
      for (let r = 0; r < this._translations.length - 1; r += 1) {
        const [a, n] = this._translations[r], [u, g] = this._translations[r + 1];
        i.moveTo(s(a, o), e(n, o)), i.lineTo(s(u, o), e(g, o));
      }
      i.stroke();
    }
  }
}
v([
  h({ type: Array })
], P.prototype, "poses");
v([
  h({ type: Array })
], P.prototype, "translations");
v([
  h({ type: String })
], P.prototype, "color");
v([
  h({ type: String })
], P.prototype, "unit");
v([
  h({ type: Number, attribute: "line-width" })
], P.prototype, "lineWidth");
v([
  h({ type: Number })
], P.prototype, "opacity");
v([
  A()
], P.prototype, "_poses");
v([
  A()
], P.prototype, "_translations");
customElements.get("frc-field-path") || customElements.define("frc-field-path", P);
var rt = Object.defineProperty, w = (p, i, t, s) => {
  for (var e = void 0, o = p.length - 1, r; o >= 0; o--)
    (r = p[o]) && (e = r(i, t, e) || e);
  return e && rt(i, t, e), e;
};
function st(p) {
  return p * Math.PI / 180;
}
var x, V, Y;
const W = class W extends j {
  constructor() {
    super(...arguments);
    R(this, V);
    R(this, x);
    this.game = T[0].game, this.cropTop = null, this.cropBottom = null, this.cropLeft = null, this.cropRight = null, this.cropType = "percent", this.unit = D, this.rotationUnit = "rad", this.rotation = 0, this.showGrid = !1, this.gridSize = 1, this.origin = "blue", I(this, x, new $());
  }
  getConfig() {
    return T.find(({ game: s }) => s === this.game) ?? T[0];
  }
  getCanvasCtx() {
    return this.canvas.getContext("2d");
  }
  getCropPercent() {
    if (this.cropType === "percent") {
      const J = this.cropLeft ?? 0, Q = this.cropTop ?? 0, Z = this.cropRight ?? 1, tt = this.cropBottom ?? 1;
      return { x1: J, y1: Q, x2: Z, y2: tt };
    }
    const { corners: t, image: s, unit: e, size: o } = this.getConfig(), { loaded: r, width: a, height: n } = b(this, x).getImage(s);
    if (!r)
      return { x1: 0, y1: 0, x2: 1, y2: 1 };
    const u = [this.cropLeft ?? 0, this.cropTop ?? 0], g = [
      this.cropRight ?? y(o[0], e, this.unit),
      this.cropBottom ?? y(o[1], e, this.unit)
    ], f = t.topLeft[0] / a, m = t.topLeft[1] / n, k = t.bottomRight[0] / a, z = t.bottomRight[1] / n, O = k - f, G = z - m;
    return {
      x1: f + O * y(u[0], this.unit, e) / o[0],
      y1: m + G * y(u[1], this.unit, e) / o[1],
      x2: f + O * y(g[0], this.unit, e) / o[0],
      y2: m + G * y(g[1], this.unit, e) / o[1]
    };
  }
  getFieldRectPx() {
    const { corners: t, image: s } = this.getConfig(), { loaded: e, width: o, height: r } = b(this, x).getImage(s);
    if (!e)
      return { x: 0, y: 0, width: 0, height: 0 };
    const a = t.topLeft[0] / o, n = t.topLeft[1] / r, u = t.bottomRight[0] / o, g = t.bottomRight[1] / r, f = this.getCropPercent(), m = f.x2 - f.x1, k = f.y2 - f.y1, z = this.canvas.width / m, O = this.canvas.height / k;
    return {
      x: (a - f.x1) * z,
      y: (n - f.y1) * O,
      width: (u - a) * z,
      height: (g - n) * O
    };
  }
  pxToX(t, s = this.unit) {
    const e = this.getFieldRectPx(), { size: o, unit: r } = this.getConfig();
    if (e.width === 0)
      return 0;
    const a = e.width / o[0], n = t * (this.canvas.width / this.canvas.clientWidth), u = this.origin !== "red" ? (n - e.x) / a : (e.x + e.width - n) / a;
    return y(u, r, s);
  }
  xToPx(t, s = this.unit) {
    const e = this.getFieldRectPx(), { size: o, unit: r } = this.getConfig();
    if (e.width === 0)
      return 0;
    const a = e.width / o[0], n = y(t, s, r);
    return this.origin !== "red" ? e.x + n * a : e.x + e.width - n * a;
  }
  yToPx(t, s = this.unit) {
    const e = this.getFieldRectPx(), { size: o, unit: r } = this.getConfig();
    if (e.height === 0)
      return 0;
    const a = e.height / o[1], n = y(t, s, r);
    return this.origin !== "red" ? e.y + e.height - n * a : e.y + n * a;
  }
  pxToY(t, s = this.unit) {
    const e = this.getFieldRectPx(), { size: o, unit: r } = this.getConfig();
    if (e.height === 0)
      return 0;
    const a = e.height / o[1], n = t * (this.canvas.height / this.canvas.clientHeight), u = this.origin !== "red" ? (e.y + e.height - n) / a : (n - e.y) / a;
    return y(u, r, s);
  }
  lengthToPx(t, s = this.unit) {
    const e = this.getFieldRectPx(), { size: o, unit: r } = this.getConfig();
    if (e.width === 0)
      return 0;
    const a = e.width / o[0];
    return y(t, s, r) * a;
  }
  setContainerSize() {
    const t = { width: this.clientWidth, height: this.clientHeight }, s = this.getConfig().image, e = b(this, x).getImage(s), { loaded: o } = e;
    if (!o)
      return;
    const r = this.getCropPercent(), a = {
      width: (r.x2 - r.x1) * e.width,
      height: (r.y2 - r.y1) * e.height
    }, n = $.getBoundingBoxDims(
      a,
      st(this.rotation)
    ), g = $.fitImageInsideBox(n, {
      width: t.width,
      height: t.height
    }).width / n.width;
    this.container.style.width = `${a.width * g}px`, this.container.style.height = `${a.height * g}px`;
  }
  drawImage() {
    const t = this.getCanvasCtx(), s = this.getConfig().image, { loaded: e, image: o, width: r, height: a } = b(this, x).getImage(s);
    if (!e)
      return;
    const { clientWidth: n, clientHeight: u } = this.canvas, g = n * window.devicePixelRatio, f = u * window.devicePixelRatio;
    this.canvas.width = g, this.canvas.height = f;
    const m = this.getCropPercent();
    t.drawImage(
      o,
      m.x1 * r,
      m.y1 * a,
      (m.x2 - m.x1) * r,
      (m.y2 - m.y1) * a,
      0,
      0,
      g,
      f
    );
  }
  drawFieldRect() {
    const t = this.getCanvasCtx(), { x: s, y: e, width: o, height: r } = this.getFieldRectPx();
    t.rect(s, e, o, r), t.lineWidth = 2, t.strokeStyle = "yellow", t.stroke();
  }
  drawGrid() {
    const t = this.getCanvasCtx(), { image: s, size: e } = this.getConfig(), { loaded: o } = b(this, x).getImage(s);
    if (!(!o || !this.showGrid || this.gridSize <= 0)) {
      t.lineWidth = 1, t.strokeStyle = "gray";
      for (let r = 0; r <= e[0]; r += this.gridSize)
        t.beginPath(), t.moveTo(this.xToPx(r), this.yToPx(0)), t.lineTo(this.xToPx(r), this.yToPx(e[1])), t.stroke();
      for (let r = 0; r <= e[1]; r += this.gridSize)
        t.beginPath(), t.moveTo(this.xToPx(0), this.yToPx(r)), t.lineTo(this.xToPx(e[0]), this.yToPx(r)), t.stroke();
    }
  }
  drawChildren() {
    const t = {
      canvas: this.getCanvasCtx(),
      getFieldRectPx: () => this.getFieldRectPx(),
      unit: this.unit,
      rotationUnit: this.rotationUnit,
      xToPx: (e, o) => this.xToPx(e, o),
      yToPx: (e, o) => this.yToPx(e, o),
      lengthToPx: (e, o) => this.lengthToPx(e, o),
      origin: this.origin
    };
    [...this.children].flatMap((e) => e.tagName === "SLOT" ? e.assignedElements() : e).forEach((e) => {
      var a;
      const o = this.getCanvasCtx();
      o.save(), o.beginPath();
      const r = e;
      (a = r.draw) == null || a.call(r, t), o.restore();
    });
  }
  drawField() {
    this.setContainerSize(), this.drawImage(), this.drawFieldRect(), this.drawGrid(), this.drawChildren(), window.requestAnimationFrame(() => {
      this.drawField();
    });
  }
  firstUpdated() {
    this.drawField();
  }
  render() {
    return L`
      <div class="outside-container">
        <div class="container" style="transform: rotate(${-this.rotation}deg)">
          <canvas @click=${X(this, V, Y)}></canvas>
        </div>
      </div>
    `;
  }
};
x = new WeakMap(), V = new WeakSet(), Y = function(t) {
  const s = this.pxToX(t.offsetX), e = this.pxToY(t.offsetY);
  this.dispatchEvent(
    new CustomEvent("fieldClick", {
      detail: {
        feet: {
          x: y(s, this.unit, "ft"),
          y: y(e, this.unit, "ft")
        },
        meters: {
          x: y(s, this.unit, "m"),
          y: y(e, this.unit, "m")
        }
      },
      bubbles: !0,
      composed: !0
    })
  );
}, W.styles = q`
    :host {
      display: inline-flex;
      position: relative;
      width: 500px;
      height: 300px;
      justify-content: center;
      align-items: center;
    }

    .container {
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  `;
let d = W;
w([
  h({ type: String })
], d.prototype, "game");
w([
  h({ type: Number, attribute: "crop-top" })
], d.prototype, "cropTop");
w([
  h({ type: Number, attribute: "crop-bottom" })
], d.prototype, "cropBottom");
w([
  h({ type: Number, attribute: "crop-left" })
], d.prototype, "cropLeft");
w([
  h({ type: Number, attribute: "crop-right" })
], d.prototype, "cropRight");
w([
  h({ type: String, attribute: "crop-type" })
], d.prototype, "cropType");
w([
  h({ type: String })
], d.prototype, "unit");
w([
  h({ type: String, attribute: "rotation-unit" })
], d.prototype, "rotationUnit");
w([
  h({ type: Number })
], d.prototype, "rotation");
w([
  h({ type: Boolean, attribute: "show-grid" })
], d.prototype, "showGrid");
w([
  h({ type: Number, attribute: "grid-size" })
], d.prototype, "gridSize");
w([
  h({ type: String })
], d.prototype, "origin");
w([
  B("canvas", !0)
], d.prototype, "canvas");
w([
  B(".container", !0)
], d.prototype, "container");
customElements.get("frc-field") || customElements.define("frc-field", d);
class nt {
  constructor(i, t) {
    this.sourceKey = "", this.sourceProvider = "", this.store = i, this.onUpdate = t;
  }
  setSource(i, t) {
    var e;
    this.sourceKey = i, this.sourceProvider = t, this.addFieldObjectsFromSources(), (e = this.unsubscriber) == null || e.call(this);
    const s = et(() => {
      this.addFieldObjectsFromSources();
    }, 1e3 / 60);
    this.unsubscriber = this.store.subscribe(t, i, s, !0);
  }
  addFieldObjectsFromSources() {
    var s;
    const i = this.store.getSource(this.sourceProvider, this.sourceKey);
    if (!i || ((s = i.getChildren()[".type"]) == null ? void 0 : s.getValue()) !== "Field2d")
      return;
    const t = [];
    Object.entries(i.getChildren()).forEach(([e, o]) => {
      if (e.startsWith(".") || e === "XModules")
        return;
      const r = o.hasChildren() ? o.getChildren().pose.getValue() : o.getValue(), a = E(r);
      t.push({
        type: a.length === 1 ? "robot" : "trajectory",
        poses: a,
        sourceKey: o.getKey(),
        sourceProvider: this.sourceProvider
      }), this.onUpdate(t);
    });
  }
}
var ht = Object.defineProperty, l = (p, i, t, s) => {
  for (var e = void 0, o = p.length - 1, r; o >= 0; o--)
    (r = p[o]) && (e = r(i, t, e) || e);
  return e && ht(i, t, e), e;
};
const ft = {
  dashboard: {
    displayName: "Field Path",
    topLevel: !1
  },
  properties: {
    poses: { type: "Array", primary: !0, input: { type: "NumberArray" } },
    color: {
      type: "String",
      input: { type: "ColorPicker" },
      defaultValue: "#FFA500"
    },
    unit: {
      type: "String",
      defaultValue: "inherit",
      input: {
        type: "StringDropdown",
        getOptions() {
          return ["inherit", ...Object.keys(M)];
        },
        allowCustomValues: !1
      }
    },
    lineWidth: {
      type: "Number",
      attribute: "line-width",
      defaultValue: 4,
      input: { type: "Number", min: 0 }
    },
    opacity: {
      type: "Number",
      defaultValue: 0.7,
      input: { type: "Number", min: 0, max: 1, step: 0.1 }
    }
  }
}, yt = {
  dashboard: {
    displayName: "Field Robot",
    topLevel: !1
  },
  properties: {
    pose: {
      type: "Array",
      defaultValue: [0, 0, 0],
      primary: !0,
      input: { type: "NumberArray" }
    },
    rotationUnit: {
      type: "String",
      attribute: "rotation-unit",
      defaultValue: "inherit",
      input: {
        type: "StringDropdown",
        getOptions: () => ["inherit", "deg", "rad"],
        allowCustomValues: !1
      }
    },
    unit: {
      type: "String",
      defaultValue: "inherit",
      input: {
        type: "StringDropdown",
        getOptions() {
          return ["inherit", ...Object.keys(M)];
        },
        allowCustomValues: !1
      }
    },
    color: {
      type: "String",
      input: { type: "ColorPicker" },
      defaultValue: "#0000ff"
    },
    opacity: {
      type: "Number",
      defaultValue: 1,
      input: { type: "Number", min: 0, max: 1, step: 0.1 }
    },
    rotation: {
      type: "Number",
      input: {
        type: "Number",
        min: -360,
        max: 360
      }
    },
    width: {
      type: "Number",
      defaultValue: 0.6
    },
    length: {
      type: "Number",
      defaultValue: 0.9
    }
  }
}, mt = {
  dashboard: {
    displayName: "Field",
    defaultHtml: `
    <frc-field-wrapper source-key="/SmartDashboard/Field" source-provider="NetworkTables">
    </frc-field-wrapper>
    `
  },
  properties: {
    provider: { type: "SourceProvider", property: "provider" },
    store: { type: "Store", property: "store" },
    sourceProvider: {
      type: "String",
      attribute: "source-provider",
      input: { type: "None" }
    },
    sourceKey: {
      type: "String",
      attribute: "source-key",
      input: { type: "None" }
    },
    game: {
      type: "String",
      defaultValue: "Charged Up",
      input: {
        type: "StringDropdown",
        allowCustomValues: !1,
        getOptions() {
          return T.map((p) => p.game);
        }
      }
    },
    rotationUnit: {
      type: "String",
      attribute: "rotation-unit",
      defaultValue: "deg",
      input: {
        type: "StringDropdown",
        getOptions: () => ["deg", "rad"],
        allowCustomValues: !1
      }
    },
    unit: {
      type: "String",
      defaultValue: D,
      input: {
        type: "StringDropdown",
        getOptions() {
          return Object.keys(M);
        },
        allowCustomValues: !1
      }
    },
    rotation: {
      type: "Number",
      input: {
        type: "Number",
        min: -360,
        max: 360
      }
    },
    showGrid: {
      type: "Boolean",
      attribute: "show-grid"
    },
    gridSize: {
      type: "Number",
      attribute: "grid-size",
      input: {
        type: "Number",
        min: 0
      }
    },
    origin: {
      type: "String",
      defaultValue: "blue",
      input: {
        type: "StringDropdown",
        getOptions: () => ["blue", "red"],
        allowCustomValues: !1
      }
    },
    cropLeft: {
      type: "Number",
      attribute: "crop-left",
      input: {
        type: "Number",
        min: 0,
        max: 100
      }
    },
    cropRight: {
      type: "Number",
      defaultValue: 100,
      attribute: "crop-right",
      input: {
        type: "Number",
        min: 0,
        max: 100
      }
    },
    cropTop: {
      type: "Number",
      attribute: "crop-top",
      input: {
        type: "Number",
        min: 0,
        max: 100
      }
    },
    cropBottom: {
      type: "Number",
      defaultValue: 100,
      attribute: "crop-bottom",
      input: {
        type: "Number",
        min: 0,
        max: 100
      }
    }
  },
  slots: [
    {
      name: "",
      allowedChildren: ["frc-field-robot", "frc-field-path"]
    }
  ]
};
var U;
const K = class K extends j {
  constructor() {
    super(...arguments);
    R(this, U);
    this.sourceProvider = "", this.sourceKey = "", this.game = T[0].game, this.cropTop = 0, this.cropBottom = 100, this.cropLeft = 0, this.cropRight = 100, this.cropType = "percent", this.unit = D, this.rotationUnit = "deg", this.rotation = 0, this.showGrid = !1, this.gridSize = 1, this.origin = "blue", this.fieldObjects = [];
  }
  firstUpdated() {
    this.store && (this.fieldObjectManager = new nt(
      this.store,
      (t) => {
        this.fieldObjects = t;
      }
    )), I(this, U, new MutationObserver(() => {
      this.requestUpdate();
    })), b(this, U).observe(this, {
      attributes: !0,
      childList: !0,
      subtree: !0,
      attributeFilter: ["source-key", "source-provider"]
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback(), b(this, U).disconnect();
  }
  updated(t) {
    (t.has("sourceKey") || t.has("sourceProvider")) && this.fieldObjectManager.setSource(this.sourceKey, this.sourceProvider);
  }
  render() {
    var e;
    const s = (((e = this.slottedFieldObjects) == null ? void 0 : e.assignedElements()) ?? []).filter((o) => o.tagName === "FRC-FIELD-ROBOT" || o.tagName === "FRC-FIELD-PATH").map((o) => ({
      type: o.tagName === "FRC-FIELD-ROBOT" ? "robot" : "trajectory",
      sourceKey: o.getAttribute("source-key"),
      sourceProvider: o.getAttribute("source-provider")
    }));
    return L`
      <frc-field
        game=${this.game}
        unit=${this.unit}
        rotation-unit=${this.rotationUnit}
        rotation=${this.rotation}
        ?show-grid=${this.showGrid}
        grid-size=${this.gridSize}
        origin=${this.origin}
        crop-top=${this.cropTop / 100}
        crop-bottom=${this.cropBottom / 100}
        crop-left=${this.cropLeft / 100}
        crop-right=${this.cropRight / 100}
        crop-type=${this.cropType}
      >
        ${this.fieldObjects.filter((o) => !s.find(
      ({ sourceKey: a, sourceProvider: n, type: u }) => o.type === u && o.sourceKey === a && o.sourceProvider === n
    )).map((o) => o.type === "robot" ? L`<frc-field-robot
                .pose=${o.poses[0]}
              ></frc-field-robot>` : L`<frc-field-path
              .poses=${o.poses}
            ></frc-field-path>`)}
        <slot></slot>
      </frc-field>
    `;
  }
};
U = new WeakMap(), K.styles = q`
    :host {
      display: inline-block;
      position: relative;
      width: 500px;
      height: 300px;
    }

    frc-field {
      width: 100%;
      height: 100%;
    }
  `;
let c = K;
l([
  h({ type: Object, attribute: !1 })
], c.prototype, "provider");
l([
  h({ type: Object, attribute: !1 })
], c.prototype, "store");
l([
  h({ type: String, attribute: "source-provider" })
], c.prototype, "sourceProvider");
l([
  h({ type: String, attribute: "source-key" })
], c.prototype, "sourceKey");
l([
  h({ type: String })
], c.prototype, "game");
l([
  h({ type: Number, attribute: "crop-top" })
], c.prototype, "cropTop");
l([
  h({ type: Number, attribute: "crop-bottom" })
], c.prototype, "cropBottom");
l([
  h({ type: Number, attribute: "crop-left" })
], c.prototype, "cropLeft");
l([
  h({ type: Number, attribute: "crop-right" })
], c.prototype, "cropRight");
l([
  h({ type: String, attribute: "crop-type" })
], c.prototype, "cropType");
l([
  h({ type: String })
], c.prototype, "unit");
l([
  h({ type: String, attribute: "rotation-unit" })
], c.prototype, "rotationUnit");
l([
  h({ type: Number })
], c.prototype, "rotation");
l([
  h({ type: Boolean, attribute: "show-grid" })
], c.prototype, "showGrid");
l([
  h({ type: Number, attribute: "grid-size" })
], c.prototype, "gridSize");
l([
  h({ type: String })
], c.prototype, "origin");
l([
  A()
], c.prototype, "fieldObjects");
l([
  B("slot", !0)
], c.prototype, "slottedFieldObjects");
customElements.get("frc-field-wrapper") || customElements.define("frc-field-wrapper", c);
export {
  d as Field,
  P as FieldPath,
  C as FieldRobot,
  c as FieldWrapper,
  D as baseUnit,
  y as convertUnit,
  d as default,
  T as fieldConfigs,
  mt as fieldDashboardConfig,
  ft as fieldPathDashboardConfig,
  yt as fieldRobotDashboardConfig,
  M as toBaseUnitConversions,
  xt as unitAliases
};
