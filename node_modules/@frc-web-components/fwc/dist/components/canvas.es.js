import { r as I, n as i, E as q, i as L, x as W } from "../property-C4BPH-wS.js";
import { a as J, e as K } from "../query-BrpQj_Qi.js";
import { r as V } from "../state-Cn3aen3G.js";
import { g as Q, t as Z } from "../index-BXxACewW.js";
import { e as tt, i as et } from "../directive-B76A7YXI.js";
import { m as rt } from "../directive-helpers-CDfQTKPA.js";
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let it;
function st(n) {
  return (t, r) => J(t, r, { get() {
    return (this.renderRoot ?? it ?? (it = document.createDocumentFragment())).querySelectorAll(n);
  } });
}
var ot = Object.defineProperty, A = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && ot(t, r, e), e;
};
class O extends I {
  constructor() {
    super(...arguments), this.points = [], this.opacity = 1, this.color = null, this.lineWidth = 2, this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["left", "top"], this.zIndex = 0, this._points = [];
  }
  updated(t) {
    t.has("points") && (this._points = Q(this.points, 2));
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), t.lineWidth = this.lineWidth ?? 2, t.strokeStyle = this.color ?? "gray";
    const [r, o, e] = this.transform ?? [
      0,
      0,
      0
    ];
    t.translate(r, o);
    const [s, a] = this.transformOrigin ?? [0, 0], d = s, l = a;
    if (t.translate(d, l), t.rotate(-(e * Math.PI) / 180), t.translate(-d, -l), this._points.length > 1) {
      for (let h = 0; h < this._points.length - 1; h += 1) {
        const [v, p] = this._points[h], [c, N] = this._points[h + 1];
        t.moveTo(v, p), t.lineTo(c, N);
      }
      t.stroke();
    }
  }
}
A([
  i({ type: Array })
], O.prototype, "points");
A([
  i({ type: Number })
], O.prototype, "opacity");
A([
  i({ type: String })
], O.prototype, "color");
A([
  i({ type: Number, attribute: "line-width" })
], O.prototype, "lineWidth");
A([
  i({ type: Array })
], O.prototype, "transform");
A([
  i({ type: Array, attribute: "transform-origin" })
], O.prototype, "transformOrigin");
A([
  i({ type: Array, attribute: "draw-origin" })
], O.prototype, "drawOrigin");
A([
  i({ type: Array, attribute: "z-index" })
], O.prototype, "zIndex");
A([
  V()
], O.prototype, "_points");
customElements.get("frc-canvas-line") || customElements.define("frc-canvas-line", O);
var at = Object.defineProperty, u = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && at(t, r, e), e;
};
class m extends I {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.width = 10, this.height = 10, this.radii = 0, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, o] = this.origin;
    const [e, s] = this.drawOrigin ?? ["center", "center"];
    e === "center" ? r -= this.width / 2 : e === "right" && (r -= this.width), s === "center" ? o -= this.height / 2 : s === "bottom" && (o -= this.height);
    const [a, d, l] = this.transform ?? [
      0,
      0,
      0
    ];
    r += a, o += d, t.translate(r, o);
    const [h, v] = this.transformOrigin ?? [0, 0], p = h + this.width / 2, c = v + this.height / 2;
    t.translate(p, c), t.rotate(-(l * Math.PI) / 180), t.translate(-p, -c), t.roundRect(0, 0, this.width, this.height, this.radii), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
u([
  i({ type: Array })
], m.prototype, "origin");
u([
  i({ type: Number })
], m.prototype, "width");
u([
  i({ type: Number })
], m.prototype, "height");
u([
  i({ type: Number })
], m.prototype, "radii");
u([
  i({ type: Number })
], m.prototype, "opacity");
u([
  i({ type: String, attribute: "stroke-color" })
], m.prototype, "strokeColor");
u([
  i({ type: Number, attribute: "stroke-width" })
], m.prototype, "strokeWidth");
u([
  i({ type: String, attribute: "fill-color" })
], m.prototype, "fillColor");
u([
  i({ type: Array })
], m.prototype, "transform");
u([
  i({ type: Array, attribute: "transform-origin" })
], m.prototype, "transformOrigin");
u([
  i({ type: Array, attribute: "draw-origin" })
], m.prototype, "drawOrigin");
u([
  i({ type: Array, attribute: "z-index" })
], m.prototype, "zIndex");
customElements.get("frc-canvas-rect") || customElements.define("frc-canvas-rect", m);
var nt = Object.defineProperty, w = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && nt(t, r, e), e;
};
class f extends I {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.radius = 10, this.startAngle = 0, this.endAngle = 360, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, o] = this.origin;
    const [e, s] = this.drawOrigin ?? ["center", "center"];
    e === "left" ? r += this.radius : e === "right" && (r -= this.radius), s === "top" ? o += this.radius : s === "bottom" && (o -= this.radius);
    const [a, d, l] = this.transform ?? [
      0,
      0,
      0
    ];
    r += a, o += d, t.translate(r, o);
    const [h, v] = this.transformOrigin ?? [0, 0], p = h, c = v;
    t.translate(p, c), t.rotate(-(l * Math.PI) / 180), t.translate(-p, -c), t.beginPath(), t.arc(
      0,
      0,
      this.radius,
      -(this.startAngle ?? 0) * Math.PI / 180,
      -(this.endAngle ?? 360) * Math.PI / 180,
      !0
    ), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
w([
  i({ type: Array })
], f.prototype, "origin");
w([
  i({ type: Number })
], f.prototype, "radius");
w([
  i({ type: Number, attribute: "start-angle" })
], f.prototype, "startAngle");
w([
  i({ type: Number, attribute: "end-angle" })
], f.prototype, "endAngle");
w([
  i({ type: Number })
], f.prototype, "opacity");
w([
  i({ type: String, attribute: "stroke-color" })
], f.prototype, "strokeColor");
w([
  i({ type: Number, attribute: "stroke-width" })
], f.prototype, "strokeWidth");
w([
  i({ type: String, attribute: "fill-color" })
], f.prototype, "fillColor");
w([
  i({ type: Array })
], f.prototype, "transform");
w([
  i({ type: Array, attribute: "transform-origin" })
], f.prototype, "transformOrigin");
w([
  i({ type: Array, attribute: "draw-origin" })
], f.prototype, "drawOrigin");
w([
  i({ type: Array, attribute: "z-index" })
], f.prototype, "zIndex");
customElements.get("frc-canvas-circle") || customElements.define("frc-canvas-circle", f);
var ht = Object.defineProperty, C = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && ht(t, r, e), e;
};
class b extends I {
  constructor() {
    super(...arguments), this.origin = [0, 0], this.sides = 5, this.radius = 10, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor, t.lineWidth = this.strokeWidth);
    let [r, o] = this.origin;
    const [e, s] = this.drawOrigin ?? ["center", "center"];
    e === "left" ? r += this.radius : e === "right" && (r -= this.radius), s === "top" ? o += this.radius : s === "bottom" && (o -= this.radius);
    const [a, d, l] = this.transform ?? [
      0,
      0,
      0
    ];
    r += a, o += d, t.translate(r, o);
    const [h, v] = this.transformOrigin ?? [0, 0], p = h, c = v;
    if (t.translate(p, c), t.rotate(-(l * Math.PI) / 180), t.translate(-p, -c), this.sides < 3) return;
    const N = Math.PI * 2 / this.sides;
    t.beginPath();
    for (let P = 0; P < this.sides; P += 1) {
      const x = P * N, M = this.radius * Math.cos(x), G = this.radius * Math.sin(x);
      P === 0 ? t.moveTo(M, G) : t.lineTo(M, G);
    }
    t.closePath(), this.fillColor && t.fill(), this.strokeColor && t.stroke();
  }
}
C([
  i({ type: Array })
], b.prototype, "origin");
C([
  i({ type: Number })
], b.prototype, "sides");
C([
  i({ type: Number })
], b.prototype, "radius");
C([
  i({ type: Number })
], b.prototype, "opacity");
C([
  i({ type: String, attribute: "stroke-color" })
], b.prototype, "strokeColor");
C([
  i({ type: Number, attribute: "stroke-width" })
], b.prototype, "strokeWidth");
C([
  i({ type: String, attribute: "fill-color" })
], b.prototype, "fillColor");
C([
  i({ type: Array })
], b.prototype, "transform");
C([
  i({ type: Array, attribute: "transform-origin" })
], b.prototype, "transformOrigin");
C([
  i({ type: Array, attribute: "draw-origin" })
], b.prototype, "drawOrigin");
C([
  i({ type: Array, attribute: "z-index" })
], b.prototype, "zIndex");
customElements.get("frc-canvas-ngon") || customElements.define("frc-canvas-ngon", b);
var lt = Object.defineProperty, R = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && lt(t, r, e), e;
};
class B extends I {
  constructor() {
    super(...arguments), this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.zIndex = 0;
  }
  draw(t) {
    const { ctx: r } = t, [o, e, s] = this.transform ?? [
      0,
      0,
      0
    ];
    r.translate(o, e);
    const [a, d] = this.transformOrigin ?? [0, 0], l = a, h = d;
    r.translate(l, h), r.rotate(-(s * Math.PI) / 180), r.translate(-l, -h), [...this.children].forEach((v) => {
      var c;
      r.save(), r.beginPath();
      const p = v;
      (c = p.draw) == null || c.call(p, t), r.restore();
    });
  }
}
R([
  i({ type: Array })
], B.prototype, "transform");
R([
  i({ type: Array, attribute: "transform-origin" })
], B.prototype, "transformOrigin");
R([
  i({ type: Array, attribute: "z-index" })
], B.prototype, "zIndex");
customElements.get("frc-canvas-group") || customElements.define("frc-canvas-group", B);
var dt = Object.defineProperty, y = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && dt(t, r, e), e;
};
class g extends I {
  constructor() {
    super(...arguments), this.text = "", this.origin = [0, 0], this.maxWidth = null, this.fontName = "sans-serif", this.fontSize = 12, this.opacity = 1, this.strokeColor = null, this.strokeWidth = 2, this.fillColor = "gray", this.transform = [0, 0, 0], this.transformOrigin = [0, 0], this.drawOrigin = ["center", "center"], this.zIndex = 0;
  }
  draw({ ctx: t }) {
    t.globalAlpha = Math.max(0, Math.min(1, this.opacity ?? 1)), this.fillColor && (t.fillStyle = this.fillColor), this.strokeColor && (t.strokeStyle = this.strokeColor), t.textAlign = "center", t.textBaseline = "middle", t.font = `${this.fontSize ?? 12}px ${this.fontName || "sans-serif"}`;
    let [r, o] = this.origin ?? [0, 0];
    const { width: e, actualBoundingBoxAscent: s, actualBoundingBoxDescent: a } = t.measureText(this.text ?? ""), d = s + a, [l, h] = this.drawOrigin ?? ["center", "center"];
    l === "left" ? r += e / 2 : l === "right" && (r -= e / 2), h === "top" ? o += d / 2 : h === "bottom" && (o -= d / 2);
    const [v, p, c] = this.transform ?? [
      0,
      0,
      0
    ];
    r += v, o += p, t.translate(r, o);
    const [N, P] = this.transformOrigin ?? [0, 0], x = N, M = P;
    t.translate(x, M), t.rotate(-(c * Math.PI) / 180), t.translate(-x, -M), this.fillColor && t.fillText(this.text ?? "", 0, 0), this.strokeColor && (t.lineWidth = this.strokeWidth ?? 2, t.strokeText(this.text ?? "", 0, 0));
  }
}
y([
  i({ type: String })
], g.prototype, "text");
y([
  i({ type: Array })
], g.prototype, "origin");
y([
  i({ type: Number, attribute: "max-width" })
], g.prototype, "maxWidth");
y([
  i({ type: String, attribute: "font-name" })
], g.prototype, "fontName");
y([
  i({ type: Number, attribute: "font-size" })
], g.prototype, "fontSize");
y([
  i({ type: Number })
], g.prototype, "opacity");
y([
  i({ type: String, attribute: "stroke-color" })
], g.prototype, "strokeColor");
y([
  i({ type: Number, attribute: "stroke-width" })
], g.prototype, "strokeWidth");
y([
  i({ type: String, attribute: "fill-color" })
], g.prototype, "fillColor");
y([
  i({ type: Array })
], g.prototype, "transform");
y([
  i({ type: Array, attribute: "transform-origin" })
], g.prototype, "transformOrigin");
y([
  i({ type: Array, attribute: "draw-origin" })
], g.prototype, "drawOrigin");
y([
  i({ type: Array, attribute: "z-index" })
], g.prototype, "zIndex");
customElements.get("frc-canvas-text") || customElements.define("frc-canvas-text", g);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const pt = tt(class extends et {
  constructor() {
    super(...arguments), this.key = q;
  }
  render(n, t) {
    return this.key = n, t;
  }
  update(n, [t, r]) {
    return t !== this.key && (rt(n), this.key = t), r;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const D = (n) => n ?? q;
var ct = Object.defineProperty, $ = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && ct(t, r, e), e;
};
const U = class U extends I {
  constructor() {
    super(...arguments), this.src = "", this.width = null, this.height = null, this.origin = [0, 0], this.disabled = !1, this.hideCrosshair = !1, this.crosshairColor = "white", this.image = new Image(), this.connected = !1, this.throttleUpdateImage = Z(() => this.updateImage(), 5e3), this.onImageLoadBound = this.onImageLoad.bind(this), this.onImageErrorBound = this.onImageError.bind(this);
  }
  getImageSize(t) {
    const r = {
      width: this.width || t.width,
      height: this.height || t.height
    };
    return this.image.height / this.image.width * r.width > r.height ? {
      height: r.height,
      width: this.image.width / this.image.height * r.height
    } : {
      height: this.image.height / this.image.width * r.width,
      width: r.width
    };
  }
  draw({ ctx: t, canvas: r }) {
    const { width: o, height: e } = this.getImageSize(r), s = {
      width: this.width || r.width,
      height: this.height || r.height
    }, [a, d] = this.origin ?? [0, 0];
    if (t.translate(a, d), !!this.connected)
      try {
        const l = (s.width - o) / 2, h = (s.height - e) / 2;
        t.drawImage(this.image, l, h, o, e), this.hideCrosshair || (t.strokeStyle = this.crosshairColor || "white", t.lineWidth = 1, t.beginPath(), t.setLineDash([7, 7]), t.moveTo(l, h + e / 2), t.lineTo(l + o, h + e / 2), t.stroke(), t.beginPath(), t.setLineDash([5, 5]), t.moveTo(l + o / 2, h), t.lineTo(l + o / 2, h + e), t.stroke());
      } catch {
        this.throttleUpdateImage();
      }
  }
  disconnectedCallback() {
    super.disconnectedCallback(), clearTimeout(this.loadedTimeout), this.image.src = "";
  }
  connectedCallback() {
    super.connectedCallback(), this.throttleUpdateImage();
  }
  isImageLoaded() {
    return this.image.complete && this.image.naturalHeight !== 0;
  }
  updateImage() {
    if (clearTimeout(this.loadedTimeout), !this.disabled) {
      if (!this.isConnected) {
        this.setConnected(!1);
        return;
      }
      this.isImageLoaded() || (this.loadedTimeout = setTimeout(() => {
        this.throttleUpdateImage();
      }, 5e3), this.image.removeEventListener("load", this.onImageLoadBound), this.image.removeEventListener("error", this.onImageErrorBound), this.image.src = "", this.image = new Image(), this.setConnected(!1), this.image.src = this.src ?? "", this.image.addEventListener("load", this.onImageLoadBound), this.image.addEventListener("error", this.onImageErrorBound));
    }
  }
  setConnected(t) {
    this.connected && !t ? (this.connected = !1, this.dispatchDisconnect()) : !this.connected && t && (this.connected = !0, this.dispatchConnect());
  }
  onImageLoad() {
    this.setConnected(!0), clearTimeout(this.loadedTimeout);
  }
  onImageError() {
    this.throttleUpdateImage();
  }
  dispatchConnect() {
    this.dispatchEvent(
      new CustomEvent("connect", {
        bubbles: !0,
        composed: !0
      })
    );
  }
  dispatchDisconnect() {
    this.dispatchEvent(
      new CustomEvent("disconnect", {
        bubbles: !0,
        composed: !0
      })
    );
  }
  updated(t) {
    t.has("src") && this.throttleUpdateImage(), t.has("disabled") && (this.disabled ? (clearTimeout(this.loadedTimeout), this.image.src = "") : this.throttleUpdateImage());
  }
};
U.styles = L`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    canvas {
      width: 100%;
      height: 100%;
    }
  `;
let k = U;
$([
  i({ type: String })
], k.prototype, "src");
$([
  i({ type: Number })
], k.prototype, "width");
$([
  i({ type: Number })
], k.prototype, "height");
$([
  i({ type: Array })
], k.prototype, "origin");
$([
  i({ type: Boolean })
], k.prototype, "disabled");
$([
  i({ type: Boolean, attribute: "hide-crosshair" })
], k.prototype, "hideCrosshair");
$([
  i({ type: String, attribute: "crosshair-color" })
], k.prototype, "crosshairColor");
customElements.get("frc-canvas-mjpg-stream-instance") || customElements.define(
  "frc-canvas-mjpg-stream-instance",
  k
);
var gt = Object.defineProperty, S = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && gt(t, r, e), e;
}, E;
const _ = (E = class extends I {
  constructor() {
    super(...arguments), this.srcs = [], this.width = null, this.height = null, this.origin = [0, 0], this.waitImage = E.DEFAULT_WAIT_IMAGE, this.hideCrosshair = !1, this.crosshairColor = "white", this.waitImageElement = new Image();
  }
  getImageSize(t) {
    const r = {
      width: this.width || t.width,
      height: this.height || t.height
    };
    return this.waitImageElement.height / this.waitImageElement.width * r.width > r.height ? {
      height: r.height,
      width: this.waitImageElement.width / this.waitImageElement.height * r.height
    } : {
      height: this.waitImageElement.height / this.waitImageElement.width * r.width,
      width: r.width
    };
  }
  draw(t) {
    const { canvas: r, ctx: o } = t, e = [...this.streamInstances].find(
      (s) => s.src === this._connectedSrc
    );
    if (e)
      e.draw(t);
    else {
      const { width: s, height: a } = this.getImageSize(r), d = {
        width: this.width || r.width,
        height: this.height || r.height
      }, [l, h] = this.origin ?? [0, 0];
      o.translate(l, h);
      try {
        o.drawImage(
          this.waitImageElement,
          (d.width - s) / 2,
          (d.height - a) / 2,
          s,
          a
        );
      } catch {
      }
    }
  }
  updated(t) {
    t.has("srcs") && this._connectedSrc && !this.srcs.includes(this._connectedSrc) && (this._connectedSrc = void 0), t.has("waitImage") && (this.waitImageElement.src = this.waitImage);
  }
  onConnect(t) {
    this._connectedSrc || (this._connectedSrc = t);
  }
  onDisconnect(t) {
    this._connectedSrc === t && (this._connectedSrc = void 0);
  }
  renderStreamInstance(t) {
    return W`
      ${pt(
      t,
      W`
          <frc-canvas-mjpg-stream-instance
            @connect=${() => this.onConnect(t)}
            @disconnect=${() => this.onDisconnect(t)}
            src=${t}
            width=${D(this.width !== null ? this.width : void 0)}
            height=${D(this.height !== null ? this.height : void 0)}
            .origin=${D(this.origin !== null ? this.origin : void 0)}
            ?disabled=${this._connectedSrc && this._connectedSrc !== t}
            ?hide-crosshair=${this.hideCrosshair}
            crosshair-color=${this.crosshairColor}
          ></frc-canvas-mjpg-stream-instance>
        `
    )}
    `;
  }
  render() {
    return W`
      ${this.srcs.map(
      (t) => this.renderStreamInstance(t.replace("mjpg:", ""))
    )}
    `;
  }
}, E.DEFAULT_WAIT_IMAGE = "./no-camera-stream.jpg", E);
S([
  i({ type: Array })
], _.prototype, "srcs");
S([
  i({ type: Number })
], _.prototype, "width");
S([
  i({ type: Number })
], _.prototype, "height");
S([
  i({ type: Array })
], _.prototype, "origin");
S([
  i({ type: String, attribute: "wait-image" })
], _.prototype, "waitImage");
S([
  i({ type: Boolean, attribute: "hide-crosshair" })
], _.prototype, "hideCrosshair");
S([
  i({ type: String, attribute: "crosshair-color" })
], _.prototype, "crosshairColor");
S([
  V()
], _.prototype, "_connectedSrc");
S([
  st("frc-canvas-mjpg-stream-instance")
], _.prototype, "streamInstances");
let H = _;
customElements.get("frc-canvas-mjpg-stream") || customElements.define("frc-canvas-mjpg-stream", H);
var mt = Object.defineProperty, X = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && mt(t, r, e), e;
};
const Y = class Y extends I {
  constructor() {
    super(...arguments), this.width = null, this.backgroundColor = "black";
  }
  getCanvasCtx() {
    return this.canvas.getContext("2d");
  }
  drawChildren() {
    const t = {
      canvas: this.canvas,
      ctx: this.getCanvasCtx(),
      domRect: this.getBoundingClientRect()
    };
    [...this.children].forEach((r) => {
      var s;
      const o = this.getCanvasCtx();
      o.save(), o.beginPath();
      const e = r;
      (s = e.draw) == null || s.call(e, t), o.restore();
    });
  }
  drawBackground() {
    const t = this.getCanvasCtx();
    t.save(), t.fillStyle = this.backgroundColor, t.fillRect(0, 0, this.canvas.width, this.canvas.height), t.restore();
  }
  drawCanvas() {
    this.drawBackground(), this.drawChildren(), window.requestAnimationFrame(() => {
      this.drawCanvas();
    });
  }
  firstUpdated() {
    this.drawCanvas(), new ResizeObserver(() => this.resized()).observe(this), this.resized();
  }
  resized() {
    const t = this.getBoundingClientRect(), { width: r, height: o } = t;
    typeof this.width != "number" ? (this.canvas.width = r, this.canvas.height = o) : (this.canvas.width = this.width, this.canvas.height = this.width * o / r);
  }
  render() {
    return W` <canvas></canvas> `;
  }
};
Y.styles = L`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    [part='box'] {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-content: center;
      flex-wrap: wrap;
      background-color: var(--box-color);
      text-align: center;
    }
  `;
let z = Y;
X([
  K("canvas")
], z.prototype, "canvas");
X([
  i({ type: Number })
], z.prototype, "width");
X([
  i({ type: String, attribute: "background-color" })
], z.prototype, "backgroundColor");
customElements.get("frc-canvas") || customElements.define("frc-canvas", z);
var ft = Object.defineProperty, j = (n, t, r, o) => {
  for (var e = void 0, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (e = a(t, r, e) || e);
  return e && ft(t, r, e), e;
};
const kt = {
  dashboard: {
    displayName: "Camera"
  },
  properties: {
    streams: { type: "Array" },
    backgroundColor: {
      type: "String",
      attribute: "background-color",
      defaultValue: "#000000",
      input: { type: "ColorPicker" }
    },
    waitImage: {
      type: "String",
      attribute: "wait-image"
      // input: { type: 'Upload' },
    },
    hideCrosshair: {
      type: "Boolean",
      attribute: "hide-crosshair"
    },
    crosshairColor: {
      type: "String",
      attribute: "crosshair-color",
      defaultValue: "#ffffff",
      input: { type: "ColorPicker" }
    }
  }
}, F = class F extends I {
  constructor() {
    super(...arguments), this.streams = [], this.backgroundColor = "black", this.waitImage = H.DEFAULT_WAIT_IMAGE, this.hideCrosshair = !1, this.crosshairColor = "white";
  }
  render() {
    return W`
      <frc-canvas background-color=${this.backgroundColor}>
        <frc-canvas-mjpg-stream
          wait-image=${this.waitImage}
          crosshair-color=${this.crosshairColor}
          ?hide-crosshair=${this.hideCrosshair}
          .srcs=${this.streams}
        ></frc-canvas-mjpg-stream>
      </frc-canvas>
    `;
  }
};
F.styles = L`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
    }

    frc-canvas {
      width: 100%;
      height: 100%;
    }
  `;
let T = F;
j([
  i({ type: Array })
], T.prototype, "streams");
j([
  i({ type: String, attribute: "background-color" })
], T.prototype, "backgroundColor");
j([
  i({ type: String, attribute: "wait-image" })
], T.prototype, "waitImage");
j([
  i({ type: Boolean, attribute: "hide-crosshair" })
], T.prototype, "hideCrosshair");
j([
  i({ type: String, attribute: "crosshair-color" })
], T.prototype, "crosshairColor");
customElements.get("frc-camera-wrapper") || customElements.define("frc-camera-wrapper", T);
export {
  T as CameraWrapper,
  z as Canvas,
  f as CanvasCircle,
  B as CanvasGroup,
  O as CanvasLine,
  H as CanvasMjpgStream,
  b as CanvasNGon,
  m as CanvasRect,
  g as CanvasText,
  kt as cameraDashboardConfig,
  z as default
};
