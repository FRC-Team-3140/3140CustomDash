import { r as b, i as M, x as w, n as c } from "../property-C4BPH-wS.js";
import { r as v } from "../state-Cn3aen3G.js";
import { e as z } from "../query-BrpQj_Qi.js";
import { s as T } from "../transform-DR-Bw75L.js";
var N = Object.defineProperty, a = (u, o, p, t) => {
  for (var n = void 0, s = u.length - 1, l; s >= 0; s--)
    (l = u[s]) && (n = l(o, p, n) || n);
  return n && N(o, p, n), n;
};
const O = {
  dashboard: {
    topLevel: !1,
    displayName: "Axis"
  },
  properties: {
    vertical: { type: "Boolean" },
    ticks: { type: "Number", defaultValue: 5 },
    min: { type: "Number", defaultValue: -1 },
    max: { type: "Number", defaultValue: 1 },
    unit: { type: "String" }
  }
}, f = class f extends b {
  constructor() {
    super(...arguments), this.vertical = !1, this.ticks = 5, this.min = -1, this.max = 1, this.unit = "", this.prevSize = 0, this.prevTicks = 0, this.prevMin = null, this.prevMax = null;
  }
  setAxis(o) {
    var y;
    const p = this.vertical ? this.clientHeight : this.clientWidth, t = p / Math.max(1, this.ticks - 1), n = 30, { min: s, max: l } = this;
    let x = -1 / 0, d = -1 / 0;
    if (this.prevSize === p && this.prevTicks === this.ticks && this.prevMin === s && this.prevMax === l && !o.has("unit") && !o.has("vertical"))
      return;
    this.prevSize = p, this.prevTicks = this.ticks, this.prevMin = s, this.prevMax = l, this.svg.innerHTML = "";
    const h = T(this.svg).attr("width", this.vertical ? n : p).attr("height", this.vertical ? p : n);
    for (let e = 0; e < this.ticks; e += 1) {
      if (this.vertical ? h.append("line").attr("x1", 0).attr("y1", e * t).attr("x2", 8).attr("y2", e * t) : h.append("line").attr("x1", e * t).attr("y1", 0).attr("x2", e * t).attr("y2", 8), this.vertical) {
        const r = s + e * (l - s) / Math.max(this.ticks - 1, 1);
        h.append("text").attr("x", -3).attr("y", e * t + 4).attr("text-anchor", "end").text(r.toFixed(2) + (this.unit ? ` ${this.unit}` : ""));
      } else {
        const r = (e - x) * t, m = x * t + r * 0.4;
        if (d < 0 || m > d) {
          const g = s + e * (l - s) / Math.max(this.ticks - 1, 1), k = h.append("text").attr("x", e * t).attr("y", 25).attr("text-anchor", "middle").text(g.toFixed(2) + (this.unit ? ` ${this.unit}` : ""));
          d = e * t + (((y = k.node()) == null ? void 0 : y.getBBox().width) ?? 0) / 2, x = e;
        }
      }
      if (e < this.ticks - 1)
        for (let r = 1; r < 4; r += 1)
          this.vertical ? h.append("line").attr("x1", 4).attr("y1", e * t + r * t / 4).attr("x2", 8).attr("y2", e * t + r * t / 4) : h.append("line").attr("x1", e * t + r * t / 4).attr("y1", 0).attr("x2", e * t + r * t / 4).attr("y2", 4);
    }
  }
  firstUpdated() {
    new ResizeObserver(() => {
      this.requestUpdate();
    }).observe(this);
  }
  updated(o) {
    this.setAxis(o);
  }
  render() {
    return w` <svg id="svg"></svg> `;
  }
};
f.styles = M`
    :host {
      display: inline-block;
      position: relative;
    }

    :host([vertical]) {
      height: 100%;
    }

    :host(:not([vertical])) {
      width: 100%;
    }

    svg {
      overflow: visible;
      position: absolute;
      top: 0;
      left: 0;
    }

    line {
      stroke: rgb(150, 150, 150);
      stroke-width: 2;
    }

    text {
      font-weight: normal;
      font-size: 13px;
      fill: var(--frc-axis-text-color, #000);
    }
  `;
let i = f;
a([
  c({ type: Boolean })
], i.prototype, "vertical");
a([
  c({ type: Number })
], i.prototype, "ticks");
a([
  c({ type: Number })
], i.prototype, "min");
a([
  c({ type: Number })
], i.prototype, "max");
a([
  c({ type: String })
], i.prototype, "unit");
a([
  v()
], i.prototype, "prevSize");
a([
  v()
], i.prototype, "prevTicks");
a([
  v()
], i.prototype, "prevMin");
a([
  v()
], i.prototype, "prevMax");
a([
  z("#svg")
], i.prototype, "svg");
customElements.get("frc-axis") || customElements.define("frc-axis", i);
export {
  i as Axis,
  O as axisDashboardConfig,
  i as default
};
