var F = (n) => {
  throw TypeError(n);
};
var I = (n, t, e) => t.has(n) || F("Cannot " + e);
var f = (n, t, e) => t.has(n) ? F("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(n) : t.set(n, e);
var r = (n, t, e) => (I(n, t, "access private method"), e);
import { r as C, i as $, x as N, n as o } from "../property-C4BPH-wS.js";
var P = Object.defineProperty, y = (n, t, e, D) => {
  for (var i = void 0, a = n.length - 1, l; a >= 0; a--)
    (l = n[a]) && (i = l(t, e, i) || i);
  return i && P(t, e, i), i;
};
const G = {
  dashboard: {
    displayName: "PID Command"
  },
  properties: {
    p: { type: "Number", changeEvent: "change" },
    i: { type: "Number", changeEvent: "change" },
    d: { type: "Number", changeEvent: "change" },
    setpoint: { type: "Number", changeEvent: "change" },
    running: { type: "Boolean", reflect: !0, changeEvent: "change" }
  }
};
var p, d;
const w = class w extends C {
  constructor() {
    super(...arguments);
    f(this, p);
    this.p = 0, this.i = 0, this.d = 0, this.setpoint = 0, this.running = !1;
  }
  onPChange(e) {
    this.p = parseFloat(e.target.value), r(this, p, d).call(this);
  }
  onIChange(e) {
    this.i = parseFloat(e.target.value), r(this, p, d).call(this);
  }
  onDChange(e) {
    this.d = parseFloat(e.target.value), r(this, p, d).call(this);
  }
  onSetpointChange(e) {
    this.setpoint = parseFloat(e.target.value), r(this, p, d).call(this);
  }
  onRunningClick() {
    this.running = !this.running, r(this, p, d).call(this);
  }
  render() {
    return N`
      <input
        type="checkbox"
        id="running"
        .checked=${this.running}
        @click=${this.onRunningClick}
      />
      <label for="running">Running</label>
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Setpoint</label>
      <input
        type="number"
        .value=${this.setpoint}
        @change=${this.onSetpointChange}
      />
    `;
  }
};
p = new WeakSet(), d = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        setpoint: this.setpoint,
        running: this.running
      }
    })
  );
}, w.styles = $`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      width: 150px;
      height: auto;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input[type='number'] {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }

    input[type='checkbox'] {
      justify-self: right;
      margin: 0;
      width: 16px;
      height: 16px;
    }

    label[for='running'] {
      justify-self: left;
    }
  `;
let s = w;
y([
  o({ type: Number })
], s.prototype, "p");
y([
  o({ type: Number })
], s.prototype, "i");
y([
  o({ type: Number })
], s.prototype, "d");
y([
  o({ type: Number })
], s.prototype, "setpoint");
y([
  o({ type: Boolean, reflect: !0 })
], s.prototype, "running");
customElements.get("frc-pid-command") || customElements.define("frc-pid-command", s);
var _ = Object.defineProperty, v = (n, t, e, D) => {
  for (var i = void 0, a = n.length - 1, l; a >= 0; a--)
    (l = n[a]) && (i = l(t, e, i) || i);
  return i && _(t, e, i), i;
};
const O = {
  dashboard: {
    displayName: "PID Controller"
  },
  properties: {
    p: { type: "Number" },
    i: { type: "Number" },
    d: { type: "Number" },
    setpoint: { type: "Number" }
  }
};
var h, b;
const k = class k extends C {
  constructor() {
    super(...arguments);
    f(this, h);
    this.p = 0, this.i = 0, this.d = 0, this.setpoint = 0;
  }
  onPChange(e) {
    this.p = parseFloat(e.target.value), r(this, h, b).call(this);
  }
  onIChange(e) {
    this.i = parseFloat(e.target.value), r(this, h, b).call(this);
  }
  onDChange(e) {
    this.d = parseFloat(e.target.value), r(this, h, b).call(this);
  }
  onSetpointChange(e) {
    this.setpoint = parseFloat(e.target.value), r(this, h, b).call(this);
  }
  render() {
    return N`
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Setpoint</label>
      <input
        type="number"
        .value=${this.setpoint}
        @change=${this.onSetpointChange}
      />
    `;
  }
};
h = new WeakSet(), b = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        setpoint: this.setpoint
      }
    })
  );
}, k.styles = $`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      height: auto;
      width: 150px;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }
  `;
let g = k;
v([
  o({ type: Number })
], g.prototype, "p");
v([
  o({ type: Number })
], g.prototype, "i");
v([
  o({ type: Number })
], g.prototype, "d");
v([
  o({ type: Number })
], g.prototype, "setpoint");
customElements.get("frc-pid-controller") || customElements.define("frc-pid-controller", g);
var S = Object.defineProperty, x = (n, t, e, D) => {
  for (var i = void 0, a = n.length - 1, l; a >= 0; a--)
    (l = n[a]) && (i = l(t, e, i) || i);
  return i && S(t, e, i), i;
};
const R = {
  dashboard: {
    displayName: "Profiled PID Controller"
  },
  properties: {
    p: { type: "Number" },
    i: { type: "Number" },
    d: { type: "Number" },
    goal: { type: "Number" }
  }
};
var u, m;
const E = class E extends C {
  constructor() {
    super(...arguments);
    f(this, u);
    this.p = 0, this.i = 0, this.d = 0, this.goal = 0;
  }
  onPChange(e) {
    this.p = parseFloat(e.target.value), r(this, u, m).call(this);
  }
  onIChange(e) {
    this.i = parseFloat(e.target.value), r(this, u, m).call(this);
  }
  onDChange(e) {
    this.d = parseFloat(e.target.value), r(this, u, m).call(this);
  }
  onGoalChange(e) {
    this.goal = parseFloat(e.target.value), r(this, u, m).call(this);
  }
  render() {
    return N`
      <label>P</label>
      <input type="number" .value=${this.p} @change=${this.onPChange} />
      <label>I</label>
      <input type="number" .value=${this.i} @change=${this.onIChange} />
      <label>D</label>
      <input type="number" .value=${this.d} @change=${this.onDChange} />
      <label>Goal</label>
      <input type="number" .value=${this.goal} @change=${this.onGoalChange} />
    `;
  }
};
u = new WeakSet(), m = function() {
  this.dispatchEvent(
    new CustomEvent("change", {
      detail: {
        p: this.p,
        i: this.i,
        d: this.d,
        goal: this.goal
      }
    })
  );
}, E.styles = $`
    :host {
      display: inline-grid;
      grid-template-columns: min-content auto;
      grid-template-rows: auto auto auto auto;
      column-gap: 10px;
      row-gap: 8px;
      align-items: center;
      height: auto;
      width: 150px;
      font-family: sans-serif;
      color: var(--frc-pid-controller-text-color, black);
    }

    label {
      font-weight: bold;
      text-align: right;
    }

    input {
      width: 100%;
      min-width: 50px;
      display: inline-block;
      box-sizing: border-box;
      padding-left: 5px;
      border-radius: 3px;
      line-height: 36px;
      height: 36px;
      border: 1px solid var(--frc-pid-controller-input-border-color, #e0e0e0);
      color: var(--frc-pid-controller-text-color, black);
      background: var(--frc-pid-controller-input-background-color, white);
    }
  `;
let c = E;
x([
  o({ type: Number })
], c.prototype, "p");
x([
  o({ type: Number })
], c.prototype, "i");
x([
  o({ type: Number })
], c.prototype, "d");
x([
  o({ type: Number })
], c.prototype, "goal");
customElements.get("frc-profiled-pid-controller") || customElements.define("frc-profiled-pid-controller", c);
export {
  s as PidCommand,
  g as PidController,
  c as ProfiledPidController,
  G as pidCommandDashboardConfig,
  O as pidControllerDashboardConfig,
  R as profiledPidControllerDashboardConfig
};
