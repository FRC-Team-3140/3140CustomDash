import { r as D, i as _, x as W, n as p, b as M } from "../property-C4BPH-wS.js";
import "./bar.es.js";
import "./axis.es.js";
import { e as B } from "../query-BrpQj_Qi.js";
import { s as N } from "../transform-DR-Bw75L.js";
function C(i) {
  return i * 180 / Math.PI;
}
function tt(i, t, e, o) {
  return `<line x1="${i}" y1="${t}" x2="${e}" y2="${o}" />`;
}
function G(i, t, e) {
  return `<polygon 
            points="${i.x},${i.y} ${t.x},${t.y} ${e.x},${e.y}" />`;
}
function j(i, t, e, o) {
  const r = o * Math.PI / 180;
  return {
    x: i + e * Math.cos(r),
    y: t - e * Math.sin(r)
  };
}
function et(i, t, e, o, r) {
  const s = j(i, t, e, r), n = j(i, t, e, o), a = r - o <= 180 ? "0" : "1", d = r > o ? 1 : 0;
  return [
    "M",
    s.x,
    s.y,
    "A",
    e,
    e,
    0,
    a,
    d,
    n.x,
    n.y
  ].join(" ");
}
function rt(i, t, e, o, r) {
  return `<path d="${et(i, t, e, o, r)}"/>`;
}
function ot(i, t, e, o) {
  const r = t / 2, s = Math.cos(i), n = Math.sin(i), a = Math.cos(i + Math.PI / 2) * r, d = Math.sin(i + Math.PI / 2) * r, c = {
    x: s * o - a + e,
    y: n * o - d
  }, h = {
    x: s * o + a + e,
    y: n * o + d
  }, l = {
    x: s * (t + o) + e,
    y: n * (t + o)
  };
  return G(c, h, l);
}
function q(i, t, e, o) {
  const r = Math.cos(t) * i, s = Math.sin(t) * i, n = tt(e, 0, r + e, s), a = ot(t, o, e, i);
  return n + a;
}
function it(i, t, e, o) {
  const r = e / t, s = C(r);
  return rt(
    o,
    0,
    t,
    C(i),
    C(i) - s
  );
}
function st(i, t, e, o, r) {
  const s = t / 2, n = r / e - i, a = Math.sqrt(t * t + e * e), d = (r + t * Math.sign(r)) / e - i, c = Math.cos(n), h = Math.sin(n), l = {
    x: (e + s) * c + o,
    y: (e + s) * h
  }, g = {
    x: (e - s) * c + o,
    y: (e - s) * h
  }, v = {
    x: a * Math.cos(d) + o,
    y: a * Math.sin(d)
  };
  return G(l, v, g);
}
function X(i, t, e, o, r) {
  if (t < 0)
    throw new Error(`Radius cannot be negative. Given: ${t}`);
  return t === 1 / 0 ? q(e, i, o, r) : it(i, t, e, o) + st(i, r, t, o, e);
}
function V(i, t, e, o, r) {
  return X(i, t, t * e, o, r);
}
var nt = Object.defineProperty, J = (i, t, e, o) => {
  for (var r = void 0, s = i.length - 1, n; s >= 0; s--)
    (n = i[s]) && (r = n(t, e, r) || r);
  return r && nt(t, e, r), r;
};
const bt = {
  dashboard: {
    displayName: "Differential Drivebase"
  },
  properties: {
    leftMotorSpeed: { type: "Number", attribute: "left-motor-speed" },
    rightMotorSpeed: { type: "Number", attribute: "right-motor-speed" }
  }
};
function I(i, t, e) {
  return Math.min(e, Math.max(i, t));
}
function at(i, t, e, o, r) {
  return (i - t) * (r - o) / (e - t) + o;
}
function dt(i) {
  const t = i / 2, e = `
    <line 
      x1="${-t}"
      y1="${-t}"
      x2="${t}"
      y2="${t}"
    />
  `, o = `
    <line 
      x1="${-t}"
      y1="${t}"
      x2="${t}"
      y2="${-t}"
    />
  `;
  return `<g class="x">${e} ${o}</g>`;
}
const A = class A extends D {
  constructor() {
    super(), this.leftMotorSpeed = 0, this.rightMotorSpeed = 0, new ResizeObserver(() => {
      this.resized();
    }).observe(this);
  }
  get clampedLeftMotorSpeed() {
    return I(this.leftMotorSpeed, -1, 1);
  }
  get clampedRightMotorSpeed() {
    return I(this.rightMotorSpeed, -1, 1);
  }
  drawMotionVector(t, e) {
    const r = this.renderRoot.querySelector("#svg").getBoundingClientRect(), s = r.width * 0.13, n = 20, a = 20, d = r.width - (s + n) * 2, c = r.height - a * 2;
    if (Math.abs(t) <= 0.05 && Math.abs(e) <= 0.05)
      return dt(r.width * 0.2);
    const h = Math.min(d, c) / 2 - 8, l = 8;
    if (Math.abs(t - e) <= 1e-3)
      return `<g class="arrow">${q(
        Math.abs(t * h),
        -Math.sign(t) * Math.PI / 2,
        0,
        l
      )}</g>`;
    const g = Math.PI, v = (e - t) / 2, b = (t + e) / 2, m = b / v;
    let k;
    if (Math.abs(m) >= 1) {
      const y = -Math.sign(m), w = (y + 1) * g / 2, x = Math.abs(m * h);
      k = X(
        w,
        x,
        y * b * h,
        y * x,
        l
      );
    } else {
      const y = Math.sign(t - e);
      if (m === 0) {
        const w = Math.max(t, e) * h, x = y * g, L = v < 0 ? g : 0;
        k = V(L, w, x, 0, l);
      } else {
        const w = m < 0 ? t : e, x = m < 0 ? e : t, L = Math.abs(w) * h, Q = -m * L, Y = at(x / w, 0, -1, 0.5, g), Z = m < 0 ? g : 0;
        k = V(
          Z,
          L,
          y * Y,
          Q,
          l
        );
      }
    }
    return `<g class="arrow">${k}</g>`;
  }
  drawDrivetrain() {
    const e = this.renderRoot.querySelector("#svg").getBoundingClientRect(), o = e.width * 0.13, r = Math.min(e.width * 0.13, e.height * 0.15), s = 20, n = 20, a = `
      <rect 
        width="calc(100% - ${(o + s) * 2}px)" 
        height="calc(100% - ${n * 2}px)"
        x="${o + s}" 
        y="20px" 
      />
    `, d = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="${s}px" 
        y="${n}px" 
      />
    `, c = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="calc(100% - ${o + s}px)" 
        y="${n}px" 
      />
    `, h = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="${s}px"
        y="calc(100% - ${r * 2 + n}px)"
      />
    `, l = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="calc(100% - ${o + s}px)" 
        y="calc(100% - ${r * 2 + n}px)"
      />
    `;
    return a + d + c + h + l;
  }
  getLeftForegroundStyle() {
    return this.getForegroundStyle(this.clampedLeftMotorSpeed);
  }
  getRightForegroundStyle() {
    return this.getForegroundStyle(this.clampedRightMotorSpeed);
  }
  getForegroundStyle(t) {
    const r = I(t, -1, 1);
    return r > 0 ? `
        height: ${Math.abs(r) / 2 * 100}%;
        top: auto;
        bottom: 50%;
      ` : `
        height: ${Math.abs(r) / 2 * 100}%;
        top: 50%;
        bottom: auto;
      `;
  }
  firstUpdated() {
    const t = this.drawMotionVector(0, 0);
    this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain(), this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  resized() {
    const t = this.drawMotionVector(
      this.clampedLeftMotorSpeed,
      this.clampedRightMotorSpeed
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
    const o = this.renderRoot.querySelector("#svg").getBoundingClientRect();
    this.renderRoot.querySelector("#forceVector").style.transform = `translate(${o.width * 0.5}px, ${o.height * 0.5}px)`, this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain();
  }
  updated() {
    const t = this.drawMotionVector(
      this.clampedLeftMotorSpeed,
      this.clampedRightMotorSpeed
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  render() {
    return W`
      <div class="diff-drive-container">
        <div class="speed">
          <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
          <div class="bar">
            <div
              class="foreground"
              style="${this.getLeftForegroundStyle()}"
            ></div>
          </div>
        </div>
        <svg id="svg">
          <g id="forceVector"></g>
          <g id="drivetrain" class="drivetrain"></g>
        </svg>
        <div class="speed">
          <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
          <div class="bar">
            <div
              class="foreground"
              style="${this.getRightForegroundStyle()}"
            ></div>
          </div>
        </div>
      </div>
    `;
  }
};
A.styles = _`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
      padding: 0 10px;
      font-family: sans-serif;
    }

    .diff-drive-container {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
    }

    svg {
      overflow: overlay;
      flex: 1;
      height: 100%;
    }

    svg .x {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
    }

    svg .arrow line,
    svg .arrow path {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
      fill: none;
    }

    svg .arrow polygon {
      stroke: rgb(50, 50, 255);
      fill: rgb(50, 50, 255);
    }

    svg .drivetrain {
      fill: none;
      stroke: var(--frc-differential-drivebase-drivetrain-color, #000);
    }

    .bar {
      position: relative;
      height: calc(100% - 30px);
      width: 20px;
      border-radius: 3px;
      margin: 15px 0;
      background: var(--frc-bar-background, #ddd);
    }

    .speed {
      display: flex;
      height: 100%;
      flex-direction: row;
      align-items: center;
      margin-left: 30px;
    }

    frc-axis {
      width: 10px;
      height: calc(100% - 35px);
    }

    .foreground {
      position: absolute;
      top: 0;
      width: 20px;
      background: var(--frc-bar-foreground, lightblue);
      border-radius: 3px;
    }
  `;
let z = A;
J([
  p({ type: Number, attribute: "left-motor-speed" })
], z.prototype, "leftMotorSpeed");
J([
  p({ type: Number, attribute: "right-motor-speed" })
], z.prototype, "rightMotorSpeed");
customElements.get("frc-differential-drivebase") || customElements.define("frc-differential-drivebase", z);
var ct = Object.defineProperty, P = (i, t, e, o) => {
  for (var r = void 0, s = i.length - 1, n; s >= 0; s--)
    (n = i[s]) && (r = n(t, e, r) || r);
  return r && ct(t, e, r), r;
};
const yt = {
  dashboard: {
    displayName: "Mecanum Drivebase"
  },
  properties: {
    frontLeftMotorSpeed: {
      type: "Number",
      attribute: "front-left-motor-speed"
    },
    frontRightMotorSpeed: {
      type: "Number",
      attribute: "front-right-motor-speed"
    },
    rearLeftMotorSpeed: { type: "Number", attribute: "rear-left-motor-speed" },
    rearRightMotorSpeed: {
      type: "Number",
      attribute: "rear-right-motor-speed"
    }
  }
};
function ht(i) {
  const t = i / 2, e = `
    <line 
      x1="${-t}"
      y1="${-t}"
      x2="${t}"
      y2="${t}"
    />
  `, o = `
    <line 
      x1="${-t}"
      y1="${t}"
      x2="${t}"
      y2="${-t}"
    />
  `;
  return `<g class="x">${e} ${o}</g>`;
}
function $(i) {
  return Math.min(1, Math.max(i, -1));
}
function F(i) {
  const o = $(i);
  return o > 0 ? `
      height: ${Math.abs(o) / 2 * 100}%;
      top: auto;
      bottom: 50%;
    ` : `
    height: ${Math.abs(o) / 2 * 100}%;
    top: 50%;
    bottom: auto;
  `;
}
const U = class U extends D {
  constructor() {
    super(), this.frontLeftMotorSpeed = 0, this.frontRightMotorSpeed = 0, this.rearLeftMotorSpeed = 0, this.rearRightMotorSpeed = 0, new ResizeObserver(() => {
      this.resized();
    }).observe(this);
  }
  drawMotionVector(t, e, o, r) {
    const n = this.renderRoot.querySelector("#svg").getBoundingClientRect(), a = n.width * 0.13, d = 20, c = 20, h = n.width - (a + d) * 2, l = n.height - c * 2, g = Math.min(h, l) / 2 - 16, v = {
      x: (t - e - o + r) / 4,
      y: (t + e + o + r) / 4
    }, b = (-t + e - o + r) / 4, m = Math.hypot(v.x, v.y), k = Math.atan2(v.y, v.x);
    if (Math.abs(b) <= 0.01 && m <= 0.01)
      return ht(n.width * 0.2);
    let y = "", w = "", x = "";
    return Math.abs(b) > 0.01 && (y = V(
      0,
      g,
      -b * Math.PI,
      0,
      8
    ), w = V(
      Math.PI,
      g,
      -b * Math.PI,
      0,
      8
    )), m > 0.01 && (x = q(
      m * g,
      -k,
      0,
      8
    )), `<g class="arrow">${y} ${w} ${x}</g>`;
  }
  drawDrivetrain() {
    const e = this.renderRoot.querySelector("#svg").getBoundingClientRect(), o = e.width * 0.13, r = Math.min(e.width * 0.13, e.height * 0.15), s = 20, n = 20, a = `
      <rect 
        width="calc(100% - ${(o + s) * 2}px)" 
        height="calc(100% - ${n * 2}px)"
        x="${o + s}" 
        y="20px" 
      />
    `, d = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="${s}px" 
        y="${n}px" 
      />
    `, c = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="calc(100% - ${o + s}px)" 
        y="${n}px" 
      />
    `, h = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="${s}px"
        y="calc(100% - ${r * 2 + n}px)"
      />
    `, l = `
      <rect 
        width="${o}px" 
        height="${r * 2}" 
        x="calc(100% - ${o + s}px)" 
        y="calc(100% - ${r * 2 + n}px)"
      />
    `;
    return a + d + c + h + l;
  }
  getFlForegroundStyle() {
    return F(this.frontLeftMotorSpeed);
  }
  getFrForegroundStyle() {
    return F(this.frontRightMotorSpeed);
  }
  getRlForegroundStyle() {
    return F(this.rearLeftMotorSpeed);
  }
  getRrForegroundStyle() {
    return F(this.rearRightMotorSpeed);
  }
  firstUpdated() {
    const t = this.drawMotionVector(0, 0, 0, 0);
    this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain(), this.renderRoot.querySelector("#forceVector").innerHTML = t;
  }
  resized() {
    const t = this.drawMotionVector(
      $(this.frontLeftMotorSpeed),
      $(this.frontRightMotorSpeed),
      $(this.rearLeftMotorSpeed),
      $(this.rearRightMotorSpeed)
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = t;
    const o = this.renderRoot.querySelector("#svg").getBoundingClientRect();
    this.renderRoot.querySelector("#forceVector").style.transform = `translate(${o.width * 0.5}px, ${o.height * 0.5}px)`, this.renderRoot.querySelector("#drivetrain").innerHTML = this.drawDrivetrain();
  }
  updated(t) {
    super.updated(t);
    const e = this.drawMotionVector(
      $(this.frontLeftMotorSpeed),
      $(this.frontRightMotorSpeed),
      $(this.rearLeftMotorSpeed),
      $(this.rearRightMotorSpeed)
    );
    this.renderRoot.querySelector("#forceVector").innerHTML = e;
  }
  render() {
    return W`
      <div class="diff-drive-container">
        <div class="speed-pair">
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getFlForegroundStyle()}"
              ></div>
            </div>
          </div>
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getRlForegroundStyle()}"
              ></div>
            </div>
          </div>
        </div>
        <svg id="svg">
          <g id="forceVector"></g>
          <g id="drivetrain" class="drivetrain"></g>
        </svg>
        <div class="speed-pair">
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getFrForegroundStyle()}"
              ></div>
            </div>
          </div>
          <div class="speed">
            <frc-axis ticks="5" vertical min="1" max="-1"></frc-axis>
            <div class="bar">
              <div
                class="foreground"
                style="${this.getRrForegroundStyle()}"
              ></div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
};
U.styles = _`
    :host {
      display: inline-block;
      width: 400px;
      height: 300px;
      padding: 0 10px;
      font-family: sans-serif;
    }

    .diff-drive-container {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
    }

    svg {
      overflow: overlay;
      flex: 1;
      height: 100%;
    }

    svg .x {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
    }

    svg .arrow line,
    svg .arrow path {
      stroke: rgb(50, 50, 255);
      stroke-width: 2;
      fill: none;
    }

    svg .arrow polygon {
      stroke: rgb(50, 50, 255);
      fill: rgb(50, 50, 255);
    }

    svg .drivetrain {
      fill: none;
      stroke: var(--frc-mecanum-drivebase-drivetrain-color, #000);
    }

    .bar {
      position: relative;
      height: calc(100% - 30px);
      width: 20px;
      border-radius: 3px;
      margin: 15px 0;
      background: var(--frc-bar-background, #ddd);
    }

    .speed-pair {
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-around;
    }

    .speed {
      display: flex;
      height: 48%;
      flex-direction: row;
      align-items: center;
      margin-left: 30px;
    }

    frc-axis {
      width: 10px;
      height: calc(100% - 35px);
    }

    .foreground {
      position: absolute;
      top: 0;
      width: 20px;
      background: var(--frc-bar-foreground, lightblue);
      border-radius: 3px;
    }
  `;
let R = U;
P([
  p({ type: Number, attribute: "front-left-motor-speed" })
], R.prototype, "frontLeftMotorSpeed");
P([
  p({ type: Number, attribute: "front-right-motor-speed" })
], R.prototype, "frontRightMotorSpeed");
P([
  p({ type: Number, attribute: "rear-left-motor-speed" })
], R.prototype, "rearLeftMotorSpeed");
P([
  p({ type: Number, attribute: "rear-right-motor-speed" })
], R.prototype, "rearRightMotorSpeed");
customElements.get("frc-mecanum-drivebase") || customElements.define("frc-mecanum-drivebase", R);
var lt = Object.defineProperty, f = (i, t, e, o) => {
  for (var r = void 0, s = i.length - 1, n; s >= 0; s--)
    (n = i[s]) && (r = n(t, e, r) || r);
  return r && lt(t, e, r), r;
};
const wt = {
  dashboard: {
    displayName: "Swerve Drivebase"
  },
  properties: {
    moduleCount: {
      type: "Number",
      defaultValue: 4,
      description: "The number of swerve modules"
    },
    wheelLocations: {
      type: "Array",
      defaultValue: [1, -1, 1, 1, -1, -1, -1, 1],
      description: "An array of numbers describing the location of the swerve module wheels relative to the physical center of the robot"
    },
    measuredStates: {
      type: "Array",
      defaultValue: [0, 0, 0, 0, 0, 0, 0, 0],
      description: "An array of rotation and velocity values describing the measured state of each swerve module"
    },
    desiredStates: {
      type: "Array",
      defaultValue: [0, 0, 0, 0, 0, 0, 0, 0],
      description: "An array of rotation and velocity values describing the desired state of each swerve module"
    },
    robotRotation: {
      type: "Number",
      description: "The robot's current rotation based on odometry or gyro readings"
    },
    maxSpeed: {
      type: "Number",
      defaultValue: 1,
      description: "The maximum achievable speed of the modules, used to adjust the size of the vectors."
    },
    rotationUnit: {
      type: "String",
      defaultValue: "radians",
      description: "The units of the module rotations and robot rotation",
      input: {
        type: "StringDropdown",
        allowCustomValues: !1,
        getOptions() {
          return ["radians", "degrees"];
        }
      }
    },
    sizeLeftRight: {
      type: "Number",
      defaultValue: 2,
      description: "The distance between the left and right modules."
    },
    sizeFrontBack: {
      type: "Number",
      defaultValue: 2,
      description: "The distance between the front and back modules."
    }
    // forwardDirection: {
    //   type: 'String',
    //   defaultValue: 'up',
    //   description:
    //     'The direction the robot should be facing when the "Robot Rotation" is zero or blank. This option is often useful to align with odometry data or match videos.',
    //   input: {
    //     type: 'StringDropdown',
    //     allowCustomValues: false,
    //     getOptions(): string[] {
    //       return ['up', 'right', 'down', 'left'];
    //     },
    //   },
    // },
    // maxAngularVelocity: {
    //   type: 'Number',
    //   defaultValue: Math.PI * 2,
    //   description:
    //     'The maximum achievable angular velocity of the robot. This is used to visualize the angular velocity from the chassis speeds properties.',
    // },
    // measuredChassisSpeeds: {
    //   type: 'Array',
    //   description:
    //     'Describes the measured forward, sideways and angular velocity of the robot',
    // },
    // desiredChassisSpeeds: {
    //   type: 'Array',
    //   description:
    //     'Describes the desired forward, sideways and angular velocity of the robot',
    // },
  }
};
function T(i, ...t) {
  return t.some((e) => i.has(e));
}
function K(i) {
  return i * Math.PI / 180;
}
function H(i) {
  return i * 180 / Math.PI;
}
function ut(i, t, e) {
  return Math.max(Math.min(i, e), t);
}
function O(i, t = !1) {
  const e = K(-(i - 90));
  return [t ? -Math.cos(e) : Math.cos(e), Math.sin(e)];
}
const S = 35, E = class E extends D {
  constructor() {
    super(...arguments), this.moduleCount = 4, this.wheelLocations = [
      2.5,
      2,
      2.5,
      -2,
      -2.5,
      2,
      -2.5,
      -2
    ], this.measuredStates = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.desiredStates = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.robotRotation = 0, this.maxSpeed = 1, this.rotationUnit = "radians", this.sizeLeftRight = 4, this.sizeFrontBack = 5, this.normalizedRotation = 0;
  }
  drawBase() {
    const [t, e] = this.getBaseSize();
    N(this._base).attr("width", t).attr("height", e).attr("stroke-width", 5).attr("fill", "none");
  }
  setSwerveRotation() {
    N(this._swerve).attr(
      "transform",
      `rotate(${-this.normalizedRotation})`
    );
  }
  setSwerveOrigin() {
    const [t, e] = this.getBaseSize();
    N(this._swerve).attr(
      "transform-origin",
      `${t / 2} ${e / 2}`
    );
  }
  getRobotRotationRad() {
    const t = this.robotRotation;
    return this.rotationUnit === "radians" ? t : K(t);
  }
  getSvgSize() {
    const { width: t } = this.getBoundingClientRect();
    return [t, t * this.sizeFrontBack / this.sizeLeftRight];
  }
  getBaseSize() {
    const [t] = this.getSvgSize();
    return [t, t * this.sizeFrontBack / this.sizeLeftRight];
  }
  updated(t) {
    if (t.has("robotRotation")) {
      const e = this.robotRotation ?? 0, r = (t.get("robotRotation") ?? e) - e, s = this.rotationUnit === "degrees" ? r : H(r), n = [
        s - 720,
        s - 360,
        s,
        s + 360,
        s + 720
      ];
      let a = 0, d = Math.abs(n[0]);
      for (let c = 1; c < n.length; c += 1) {
        const h = Math.abs(n[c]);
        h < d && (a = c, d = h);
      }
      this.normalizedRotation -= n[a];
    }
    T(
      t,
      "sizeLeftRight",
      "sizeFrontBack",
      "robotRotation",
      "rotationUnit"
    ) && this.drawBase(), T(t, "robotRotation", "rotationUnit") && this.setSwerveRotation(), T(t, "sizeLeftRight", "sizeFrontBack") && this.setSwerveOrigin();
  }
  resized() {
    const [t, e] = this.getSvgSize();
    N(this._svg).attr("width", t).attr("height", e), this.drawBase(), this.setSwerveOrigin(), this.requestUpdate();
  }
  firstUpdated() {
    new ResizeObserver(() => {
      this.resized();
    }).observe(this), this.resized();
  }
  getSwerveModules() {
    const t = [];
    for (let e = 0; e < this.moduleCount; e += 1) {
      const r = {
        location: [
          this.wheelLocations[e * 2],
          this.wheelLocations[e * 2 + 1]
        ],
        desiredRotation: this.desiredStates[e * 2],
        desiredVelocity: this.desiredStates[e * 2 + 1],
        measuredRotation: this.measuredStates[e * 2],
        measuredVelocity: this.measuredStates[e * 2 + 1]
      };
      t.push(r);
    }
    return t;
  }
  renderModuleDirectionIndicator(t, e, o) {
    const r = this.rotationUnit === "degrees" ? e : H(e), [s, n] = O(r - 15, !0), [a, d] = O(r + 15, !0), c = `M ${-s * 60},${n * 60} L 0,0 ${-a * 60},${d * 60}`;
    return M`
      <defs>
        <clipPath id=${t}>
          <path d=${c} fill="white" stroke="5" stroke="white" />
        </clipPath>
      </defs>
      <circle r=${S - 2.5} fill=${o} stroke-width="0" clip-path=${`url(#${t})`}></circle>
    `;
  }
  renderModuleVelocityIndicator(t, e, o, r) {
    const s = this.rotationUnit === "degrees" ? e : H(e);
    let n = ut(100 * o / this.maxSpeed, -100, 100);
    n += S * Math.sign(n), n *= -1;
    const a = Math.abs(n) - 20, d = Math.abs(n), c = `M -17.5,${a} L 2.5,${d} L 22.5,${a}`, h = `rotate(${-s + (n < 0 ? 180 : 0)})`, l = `${t}-velocity`;
    return M`
     <defs>
        <mask id=${l}>
          <circle r="300" fill="white" ></circle>
          <circle r=${S + 2.5} fill="black" ></circle>
        </mask>
      </defs>
      <g class="velocity-indicator" transform=${h} mask="url(#${l})">
        <rect width="5" height=${Math.abs(n)} fill=${r}></rect>
        <path d=${c} stroke=${r} stroke-width="5" fill="none" />
      </g>
    `;
  }
  renderModules() {
    const t = this.getSwerveModules(), [e, o] = this.getBaseSize();
    return M`
      <g class="modules">
        ${t.map((r, s) => {
      const {
        desiredRotation: n,
        measuredRotation: a,
        location: d,
        measuredVelocity: c,
        desiredVelocity: h
      } = r, l = o / 2 * (1 - d[0]) + S * Math.sign(d[0]), g = e / 2 * (d[1] + 1) - S * Math.sign(d[1]), v = `module-${s}-measured-clip`, b = `module-${s}-desired-clip`;
      return M`
            <g transform=${`translate(${g}, ${l})`}>
              <circle class="module-circle" r=${S} stroke-width="5" fill="none"></circle>
              ${this.renderModuleDirectionIndicator(
        v,
        a,
        "blue"
      )}
              ${this.renderModuleDirectionIndicator(
        b,
        n,
        "red"
      )}
              ${this.renderModuleVelocityIndicator(
        v,
        a,
        c,
        "blue"
      )}
              ${this.renderModuleVelocityIndicator(
        b,
        n,
        h,
        "red"
      )}
            </g>
          `;
    })} 
      </g>
    `;
  }
  renderWheelMask() {
    const t = this.getSwerveModules(), [e, o] = this.getBaseSize();
    return M`
      <defs>
        <mask id="wheel-mask">
          <rect fill="white" width=${e} height=${o} stroke-width="5" stroke="white"></rect>
          ${t.map((r) => {
      const s = o / 2 - o * r.location[0] / this.sizeFrontBack, n = e / 2 - e * r.location[1] / this.sizeLeftRight;
      return M`
              <circle r="50" fill="black" transform=${`translate(${n}, ${s})`}></circle>
            `;
    })}
        </mask>
      </defs>
    `;
  }
  renderArrow() {
    const [t, e] = this.getBaseSize(), o = `M ${t / 2 - 30},100 L ${t / 2},70 L ${t / 2 + 30},100`;
    return M`
      <line class="arrow" x1=${t / 2} y1=${70} x2=${t / 2} y2=${e - 30} stroke-width="5" />
      <path class="arrow" d=${o} stroke-width="5" fill="none" />
    `;
  }
  render() {
    return W`
      <div>
        ${M`
          <svg>
            ${this.renderWheelMask()}
            <g class="swerve">
              <rect class="base" rx=${S}></rect>
              ${this.renderModules()}
              ${this.renderArrow()}
            </g>
          </svg>
      `}
      </div>
    `;
  }
};
E.styles = _`
    :host {
      display: inline-block;
      width: 300px;
      height: auto;
      overflow: visible;
    }

    svg {
      width: 100%;
      overflow: visible;
    }

    .base {
      stroke: var(--frc-swerve-drive-color, black);
    }

    .arrow {
      stroke: var(--frc-swerve-drive-color, black);
    }

    .module-circle {
      stroke: var(--frc-swerve-drive-color, black);
    }
  `;
let u = E;
f([
  p({ type: Number, attribute: "module-count" })
], u.prototype, "moduleCount");
f([
  p({ type: Array, attribute: "wheel-locations" })
], u.prototype, "wheelLocations");
f([
  p({ type: Array, attribute: "measured-states" })
], u.prototype, "measuredStates");
f([
  p({ type: Array, attribute: "desired-states" })
], u.prototype, "desiredStates");
f([
  p({ type: Number, attribute: "robot-rotation" })
], u.prototype, "robotRotation");
f([
  p({ type: Number, attribute: "max-speed" })
], u.prototype, "maxSpeed");
f([
  p({ type: String, attribute: "rotation-unit" })
], u.prototype, "rotationUnit");
f([
  p({ type: Number, attribute: "size-left-right" })
], u.prototype, "sizeLeftRight");
f([
  p({ type: Number, attribute: "size-front-back" })
], u.prototype, "sizeFrontBack");
f([
  B("svg")
], u.prototype, "_svg");
f([
  B(".swerve")
], u.prototype, "_swerve");
f([
  B(".base")
], u.prototype, "_base");
f([
  B(".modules")
], u.prototype, "_modules");
customElements.get("frc-swerve-drivebase") || customElements.define("frc-swerve-drivebase", u);
export {
  z as DifferentialDrivebase,
  R as MecanumDrivebase,
  u as SwerveDrivebase,
  bt as differentialDrivebaseDashboardConfig,
  yt as mecanumDrivebaseDashboardConfig,
  wt as swerveDrivebaseDashboardConfig
};
