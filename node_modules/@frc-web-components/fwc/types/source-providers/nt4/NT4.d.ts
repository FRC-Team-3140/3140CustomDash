export declare class NT4_Topic {
    uid: number;
    name: string;
    type: string;
    properties: {
        [id: string]: any;
    };
    toPublishObj(): {
        name: string;
        type: string;
        pubuid: number;
        properties: {
            [id: string]: any;
        };
    };
    toUnpublishObj(): {
        pubuid: number;
    };
    getTypeIdx(): number;
}
export declare class NT4_Client {
    private appName;
    private onTopicAnnounce;
    private onTopicUnannounce;
    private onNewTopicData;
    private onConnect;
    private onDisconnect;
    private serverBaseAddr;
    private ws;
    private clientIdx;
    private useSecure;
    private serverAddr;
    private serverConnectionActive;
    private serverConnectionRequested;
    private serverTimeOffset_us;
    private uidCounter;
    private subscriptions;
    private publishedTopics;
    private serverTopics;
    /**
     * Creates a new NT4 client without connecting.
     * @param serverAddr Network address of NT4 server
     * @param appName Identifier for this client (does not need to be unique).
     * @param onTopicAnnounce Gets called when server announces enough topics to form a new signal
     * @param onTopicUnannounce Gets called when server unannounces any part of a signal
     * @param onNewTopicData Gets called when any new data is available
     * @param onConnect Gets called once client completes initial handshake with server
     * @param onDisconnect Gets called once client detects server has disconnected
     */
    constructor(serverAddr: string, appName: string, onTopicAnnounce: (topic: NT4_Topic) => void, onTopicUnannounce: (topic: NT4_Topic) => void, onNewTopicData: (topic: NT4_Topic, timestamp_us: number, value: unknown) => void, onConnect: () => void, //
    onDisconnect: () => void);
    /** Starts the connection. The client will reconnect automatically when disconnected. */
    connect(): void;
    /** Terminates the connection. */
    disconnect(): void;
    /**
     * Add a new subscription, reading data at the specified frequency.
     * @param topicPatterns A list of topics or prefixes to include in the subscription.
     * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
     * @param period The period to return data in seconds.
     * @returns A subscription ID that can be used to unsubscribe.
     */
    subscribePeriodic(topicPatterns: string[], prefixMode: boolean, period: number): number;
    /**
     * Add a new subscription, reading all value updates.
     * @param topicPatterns A list of topics or prefixes to include in the subscription.
     * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
     * @returns A subscription ID that can be used to unsubscribe.
     */
    subscribeAll(topicPatterns: string[], prefixMode: boolean): number;
    /**
     * Add a new subscription, reading only topic announcements (not values).
     * @param topicPatterns A list of topics or prefixes to include in the subscription.
     * @param prefixMode If true, use patterns as prefixes. If false, only subscribe to topics that are an exact match.
     * @returns A subscription ID that can be used to unsubscribe.
     */
    subscribeTopicsOnly(topicPatterns: string[], prefixMode: boolean): number;
    /** Given an existing subscription, unsubscribe from it. */
    unsubscribe(subscriptionId: number): void;
    /** Unsubscribe from all current subscriptions. */
    clearAllSubscriptions(): void;
    /**
     * Set the properties of a particular topic.
     * @param topic The topic to update
     * @param properties The set of new properties
     */
    setProperties(topic: string, properties: {
        [id: string]: any;
    }): void;
    /** Set whether a topic is persistent.
     *
     * If true, the last set value will be periodically saved to
     * persistent storage on the server and be restored during server
     * startup. Topics with this property set to true will not be
     * deleted by the server when the last publisher stops publishing.
     */
    setPersistent(topic: string, isPersistent: boolean): void;
    /** Set whether a topic is retained.
     *
     * Topics with this property set to true will not be deleted by
     * the server when the last publisher stops publishing.
     */
    setRetained(topic: string, isRetained: boolean): void;
    /** Publish a new topic from this client with the provided name and type. */
    publishNewTopic(topic: string, type: string): void;
    /** Unpublish a previously-published topic from this client. */
    unpublishTopic(topic: string): void;
    /** Send some new value to the server. The timestamp is whatever the current time is. */
    addSample(topic: string, value: any): void;
    /** Send some new timestamped value to the server. */
    addTimestampedSample(topic: string, timestamp: number, value: any): void;
    /** Returns the current client time in microseconds. */
    getClientTime_us(): number;
    /** Returns the current server time in microseconds (or null if unknown). */
    getServerTime_us(): number | null;
    private ws_sendTimestamp;
    private ws_handleReceiveTimestamp;
    private ws_subscribe;
    private ws_unsubscribe;
    private ws_publish;
    private ws_unpublish;
    private ws_setproperties;
    private ws_sendJSON;
    private ws_sendBinary;
    private ws_onOpen;
    private ws_onClose;
    private ws_onError;
    private ws_onMessage;
    private ws_connect;
    private getNewUID;
}
